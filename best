local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent")
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local PetsModule = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Data"):WaitForChild("Pets"))

if REMOVE_EGG_ANIMATION then
    require(game:GetService("ReplicatedStorage").Client.Effects.HatchEgg).Play = function() return end
end

local function deletePets()
    local data = LocalData:Get()
    if data and data.Pets then
        for _, pet in pairs(data.Pets) do
            local petInfo = PetsModule[pet.Name]
            if petInfo then
                local shouldKeep = false
                for _, rarity in ipairs(RARITIES_TO_KEEP) do
                    if petInfo.Rarity == rarity then
                        shouldKeep = true
                        break
                    end
                end
                
                if not shouldKeep then
                    local args1 = {"DeletePet", pet.Id, 100, false}
                    local args2 = {"DeletePet", pet.Id, 10, false}
                    local args3 = {"DeletePet", pet.Id, 1, false}
                    Network:FireServer(unpack(args1))
                    Network:FireServer(unpack(args2))
                    Network:FireServer(unpack(args3))
                    task.wait(0.1)
                end
            end
        end
    end
end

while true do
    local hatchEndTime = os.time() + HATCH_DURATION
    while os.time() < hatchEndTime do
        local hatchArgs = {"HatchPowerupEgg", EGG_NAME, 12}
        Network:FireServer(unpack(hatchArgs))
        task.wait(1)
    end
    
    local deleteEndTime = os.time() + DELETE_DURATION
    while os.time() < deleteEndTime do
        deletePets()
        task.wait(0.5)
    end
end
