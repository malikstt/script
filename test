local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ok, LocalData = pcall(function() return require(ReplicatedStorage.Client.Framework.Services.LocalData) end)
if not ok then LocalData = nil end
local ok2, ShopsModule = pcall(function() return require(ReplicatedStorage.Shared.Data.Shops) end)
if not ok2 then 
    print("Failed to load ShopsModule")
    return 
end

local function safeWait(t)
    if type(t) ~= "number" then t = 0.1 end
    if task and type(task.wait) == "function" then 
        task.wait(t) 
    else 
        wait(t) 
    end
end

local function findRemoteEvent()
    for i = 1, 20 do
        local shared = ReplicatedStorage:FindFirstChild("Shared")
        if shared then
            local framework = shared:FindFirstChild("Framework")
            if framework then
                local network = framework:FindFirstChild("Network")
                if network then
                    local remote = network:FindFirstChild("Remote")
                    if remote then
                        local evt = remote:FindFirstChild("RemoteEvent") or remote:FindFirstChildWhichIsA("RemoteEvent")
                        if evt then return evt end
                    end
                end
            end
        end
        safeWait(0.1)
    end
    return nil
end

local RemoteEvent = findRemoteEvent()

if not RemoteEvent then
    print("No RemoteEvent found!")
    return
end

local function tryGet(t, ...)
    if type(t) ~= "table" then return nil end
    for i = 1, select("#", ...) do
        local k = select(i, ...)
        if t[k] ~= nil then return t[k] end
    end
    return nil
end

local function extractCost(def)
    if type(def) ~= "table" then return nil end
    local c = tryGet(def, "Cost", "Price", "CostInfo", "PriceInfo") or tryGet(def and def.Product, "Cost", "Price")
    if type(c) == "number" then
        local cur = tryGet(def, "Currency", "CurrencyType") or "Currency"
        return { Amount = c, Currency = cur }
    end
    if type(c) == "table" then
        local amt = tryGet(c, "Amount", "Value", "Price", "Cost")
        local cur = tryGet(c, "Currency", "CurrencyType") or tryGet(def, "Currency", "CurrencyType") or "Currency"
        if amt ~= nil then return { Amount = (type(amt)=="number" and amt) or tonumber(amt) or 0, Currency = cur } end
    end
    local amt2 = tryGet(def, "Amount", "Value", "Price", "Cost") or tryGet(def and def.Product, "Amount", "Value")
    local cur2 = tryGet(def, "Currency", "CurrencyType") or tryGet(def and def.Product, "Currency", "CurrencyType")
    if amt2 ~= nil then return { Amount = (type(amt2)=="number" and amt2) or tonumber(amt2) or 0, Currency = cur2 or "Currency" } end
    return nil
end

local function extractProduct(def)
    local p = tryGet(def, "Product", "Reward", "Item", "Result") or def
    if type(p) == "table" then
        return {
            Name = tostring(tryGet(p, "Name", "Label", "Title", "DisplayName", "ItemName") or "(no Name)"),
            Type = tostring(tryGet(p, "Type", "Category") or typeof(p)),
            Level = tonumber(tryGet(p, "Level")) or nil,
            Amount = tonumber(tryGet(p, "Amount", "Quantity", "Count")) or nil
        }
    end
    if typeof(p) == "Instance" then
        return { Name = tostring(p.Name), Type = "Instance", Level = nil, Amount = nil }
    end
    return { Name = tostring(p), Type = typeof(p), Level = nil, Amount = nil }
end

local function fmtNumber(n)
    if type(n) ~= "number" then return tostring(n) end
    local absn = math.abs(n)
    if absn >= 1e15 then return string.format("%.2fP", n/1e15) end
    if absn >= 1e12 then return string.format("%.2fT", n/1e12) end
    if absn >= 1e9  then return string.format("%.2fB", n/1e9) end
    if absn >= 1e6  then return string.format("%.2fM", n/1e6) end
    if absn >= 1e3  then return string.format("%.2fK", n/1e3) end
    return tostring(n)
end

local function findCurrencyAmount(playerData, currencyName)
    if type(playerData) ~= "table" or not currencyName then return 0 end
    if type(playerData[currencyName]) == "number" then return playerData[currencyName] end
    local alt = playerData.Data or playerData.data
    if type(alt) == "table" and type(alt[currencyName]) == "number" then return alt[currencyName] end
    for k,v in pairs(playerData) do
        if type(k) == "string" and string.lower(k) == string.lower(currencyName) and type(v) == "number" then
            return v
        end
        if type(v) == "table" and type(v[currencyName]) == "number" then
            return v[currencyName]
        end
    end
    return 0
end

local function safeFire(argsTable)
    if not RemoteEvent then return false, "no remote" end
    local ok, err = pcall(function() 
        RemoteEvent:FireServer(unpack(argsTable)) 
    end)
    return ok, err
end

local rules = {
    ["Speed"] = 7,
    ["Mythic"] = 7,
    ["Lucky"] = 7,
    ["Luck"] = 7,
    ["Festive Elixir"] = 4,
    ["Festive Infinity Elixir"] = 1,
}

local function matchesRuleExact(prod)
    if type(prod) ~= "table" then return false end
    local name = prod.Name or ""
    local level = prod.Level
    local req = rules[name]
    if req ~= nil then
        if type(req) == "number" then
            return level ~= nil and level == req
        end
        return true
    end
    return false
end

local function getPlayerData()
    if LocalData and type(LocalData.Get) == "function" then
        local ok, data = pcall(function() return LocalData:Get() end)
        if ok and type(data) == "table" then return data end
    end
    return {}
end

local playerDataCache = getPlayerData()

for shopKey, shopDef in pairs(ShopsModule) do
    if type(shopDef) ~= "table" then continue end
    
    local perm = shopDef.PermanentItems or {}
    local rand = shopDef.RandomItems or {}
    local combined = {}
    
    for i,entry in pairs(perm) do combined[#combined+1] = entry end
    for i,entry in pairs(rand) do combined[#combined+1] = entry end

    for slotIndex, slotDef in pairs(combined) do
        if type(slotDef) ~= "table" then continue end
        
        local prod = extractProduct(slotDef)
        if matchesRuleExact(prod) then
            local costTbl = extractCost(slotDef) or extractCost(slotDef.Product) or extractCost(shopDef)
            local pricePer = (costTbl and tonumber(costTbl.Amount)) or 0
            local currencyName = (costTbl and costTbl.Currency) or "Currency"
            
            -- Refresh player data
            playerDataCache = getPlayerData()
            local balance = findCurrencyAmount(playerDataCache, currencyName) or 0
            
            local stock = tonumber(tryGet(slotDef, "Stock", "MaxStock", "Amount")) or math.huge
            
            if pricePer <= 0 then
                -- Free purchase
                local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                local okfire, err = safeFire(args)
                if okfire then
                    print(("%s Bought ALL x %s Qty:%s Cost:free"):format(tostring(shopKey), tostring(prod.Name), tostring(stock)))
                else
                    warn("Purchase failed:", err)
                end
                safeWait(0.25)
            else
                local maxAffordable = math.floor(balance / pricePer)
                if maxAffordable <= 0 then
                    print(("Cannot afford %s in %s (balance: %s)"):format(prod.Name, shopKey, fmtNumber(balance)))
                    continue
                end
                
                local toBuy = math.min(stock, maxAffordable)
                if toBuy <= 0 then continue end
                
                if toBuy >= stock then
                    -- Buy all
                    local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                    local okfire, err = safeFire(args)
                    if okfire then
                        local totalCost = pricePer * stock
                        print(("%s Bought ALL (%d) x %s Cost: %s %s"):format(
                            tostring(shopKey), stock, tostring(prod.Name), 
                            fmtNumber(totalCost), tostring(currencyName)
                        ))
                    else
                        warn("Bulk purchase failed:", err)
                    end
                    safeWait(0.35)
                else
                    -- Buy individual items
                    local bought = 0
                    local totalCost = 0
                    local maxIndividualBuys = math.min(toBuy, 100) -- Safety limit
                    
                    for i = 1, maxIndividualBuys do
                        local args = { "BuyShopItem", tostring(shopKey), slotIndex, false }
                        local okfire, err = safeFire(args)
                        if not okfire then 
                            warn("Individual purchase failed:", err)
                            break 
                        end
                        bought = bought + 1
                        totalCost = totalCost + pricePer
                        safeWait(0.22)
                    end
                    
                    if bought > 0 then
                        print(("%s Bought %d x %s Cost: %s %s"):format(
                            tostring(shopKey), bought, tostring(prod.Name), 
                            fmtNumber(totalCost), tostring(currencyName)
                        ))
                    end
                end
            end
        end
        safeWait(0.12)
    end
    safeWait(0.25)
end

print("Done.")
