-- Buys only the specified potions using the game's real shop data layout.
-- Exact-name & level rules:
--   Speed (Level 7), Mythic (Level 7), Lucky or Luck (Level 7),
--   Festive Elixir (Level 4), Festive Infinity Elixir (Level 1)
-- Uses player data currency fields like data.Snowflakes / data.Coins / data.Gems.
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local task = task

local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local ShopsModule = require(ReplicatedStorage.Shared.Data.Shops)
local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent")

if not LocalData:IsReady() then LocalData.DataReady:Wait() end

local function tryGet(t, ...)
    if type(t) ~= "table" then return nil end
    for i = 1, select("#", ...) do
        local k = select(i, ...)
        if t[k] ~= nil then return t[k] end
    end
    return nil
end

local function extractCost(def)
    if not def then return nil end
    local c = tryGet(def, "Cost", "Price", "CostInfo", "PriceInfo") or tryGet(def and def.Product, "Cost", "Price")
    if type(c) == "number" then
        local cur = tryGet(def, "Currency", "CurrencyType") or "Currency"
        return { Amount = c, Currency = cur }
    end
    if type(c) == "table" then
        local amt = tryGet(c, "Amount", "Value", "Price", "Cost")
        local cur = tryGet(c, "Currency", "CurrencyType") or tryGet(def, "Currency", "CurrencyType") or "Currency"
        if amt ~= nil then return { Amount = (type(amt)=="number" and amt) or tonumber(amt) or 0, Currency = cur } end
    end
    local amt2 = tryGet(def, "Amount", "Value", "Price", "Cost") or tryGet(def and def.Product, "Amount", "Value")
    local cur2 = tryGet(def, "Currency", "CurrencyType") or tryGet(def and def.Product, "Currency", "CurrencyType")
    if amt2 ~= nil then return { Amount = (type(amt2)=="number" and amt2) or tonumber(amt2) or 0, Currency = cur2 or "Currency" } end
    return nil
end

local function extractProduct(def)
    local p = tryGet(def, "Product", "Reward", "Item", "Result") or def
    if type(p) == "table" then
        return {
            Name = tostring(tryGet(p, "Name", "Label", "Title", "DisplayName", "ItemName") or "(no Name)"),
            Type = tostring(tryGet(p, "Type", "Category") or typeof(p)),
            Level = tonumber(tryGet(p, "Level")) or nil,
            Amount = tonumber(tryGet(p, "Amount", "Quantity", "Count")) or nil
        }
    end
    if typeof(p) == "Instance" then
        return { Name = tostring(p.Name), Type = "Instance", Level = nil, Amount = nil }
    end
    return { Name = tostring(p), Type = typeof(p), Level = nil, Amount = nil }
end

local function fmtNumber(n)
    if type(n) ~= "number" then return tostring(n) end
    local absn = math.abs(n)
    if absn >= 1e15 then return string.format("%.2fP", n/1e15) end
    if absn >= 1e12 then return string.format("%.2fT", n/1e12) end
    if absn >= 1e9  then return string.format("%.2fB", n/1e9) end
    if absn >= 1e6  then return string.format("%.2fM", n/1e6) end
    if absn >= 1e3  then return string.format("%.2fK", n/1e3) end
    return tostring(n)
end

local function findCurrencyAmount(playerData, currencyName)
    if not playerData or not currencyName then return 0 end
    -- direct: data.Snowflakes style
    if type(playerData[currencyName]) == "number" then return playerData[currencyName] end
    -- some games store under Data or data
    local alt = playerData.Data or playerData.data
    if type(alt) == "table" and type(alt[currencyName]) == "number" then return alt[currencyName] end
    -- fallback scan
    for k,v in pairs(playerData) do
        if type(k) == "string" and string.lower(k) == string.lower(currencyName) and type(v) == "number" then
            return v
        end
    end
    return 0
end

local function safeFire(argsTable)
    local ok, err = pcall(function() RemoteEvent:FireServer(unpack(argsTable)) end)
    return ok, err
end

local rules = {
    ["Speed"] = 7,
    ["Mythic"] = 7,
    ["Lucky"] = 7,
    ["Luck"] = 7,
    ["Festive Elixir"] = 4,
    ["Festive Infinity Elixir"] = 1,
}

local function matchesRuleExact(prod)
    if not prod or type(prod) ~= "table" then return false end
    local name = prod.Name or ""
    local level = prod.Level
    local req = rules[name]
    if req ~= nil then
        if type(req) == "number" then
            return level ~= nil and level == req
        end
        return true
    end
    return false
end

local function qtyFromValue(v)
    if type(v) == "boolean" then return v and math.huge or 0 end
    if type(v) == "number" then return v end
    if type(v) == "table" then return tonumber(tryGet(v, "Amount","Count","Qty","Quantity")) or 0 end
    return 0
end

local playerDataCache = LocalData:Get() or {}

for shopKey, shopDef in pairs(ShopsModule) do
    local perm = shopDef.PermanentItems or {}
    local rand = shopDef.RandomItems or {}
    local combined = {}
    for i,entry in pairs(perm) do combined[i] = entry end
    for i,entry in pairs(rand) do combined[i] = entry end

    for slotIndex, slotDef in pairs(combined) do
        local prod = extractProduct(slotDef)
        if matchesRuleExact(prod) then
            local costTbl = extractCost(slotDef) or extractCost(slotDef and slotDef.Product) or extractCost(shopDef)
            local pricePer = (costTbl and tonumber(costTbl.Amount)) or nil
            local currencyName = (costTbl and costTbl.Currency) or "(unknown)"
            local stock = tonumber(tryGet(slotDef, "Stock", "MaxStock", "Amount")) or math.huge

            playerDataCache = LocalData:Get() or playerDataCache
            local balance = findCurrencyAmount(playerDataCache, currencyName) or 0

            if not pricePer or pricePer <= 0 then
                local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                local ok,_ = safeFire(args)
                if ok then
                    print(("%s Bought ALL x %s Qty:%s Cost:free/unknown"):format(tostring(shopKey), tostring(prod.Name), tostring(stock)))
                end
                task.wait(0.25)
            else
                local maxAffordable = math.floor(balance / pricePer)
                local toBuy = math.min(stock, maxAffordable)
                if toBuy <= 0 then
                    -- cannot afford
                else
                    if toBuy >= stock then
                        local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                        local ok,_ = safeFire(args)
                        if ok then
                            local totalCost = pricePer * stock
                            print(("%s Bought ALL (%d) x %s Cost: %s %s"):format(tostring(shopKey), tonumber(stock), tostring(prod.Name), fmtNumber(totalCost), tostring(currencyName)))
                        end
                        task.wait(0.35)
                    else
                        local bought = 0
                        local totalCost = 0
                        for i = 1, toBuy do
                            local args = { "BuyShopItem", tostring(shopKey), slotIndex, false }
                            local ok,_ = safeFire(args)
                            if not ok then break end
                            bought = bought + 1
                            totalCost = totalCost + pricePer
                            task.wait(0.22)
                        end
                        if bought > 0 then
                            print(("%s Bought %d x %s Cost: %s %s"):format(tostring(shopKey), bought, tostring(prod.Name), fmtNumber(totalCost), tostring(currencyName)))
                        end
                    end
                end
            end
        end
        task.wait(0.12)
    end
    task.wait(0.25)
end

print("Done.")    ["Festive Infinity Elixir"] = 1,
}

local function matchesExactRule(prod)
    if not prod or type(prod) ~= "table" then return false end
    local name = prod.Name or ""
    local level = prod.Level
    local req = exactRules[name]
    if req ~= nil then
        if type(req) == "number" then
            return level ~= nil and level == req
        end
        return true
    end
    return false
end

local function qtyFromValue(v)
    if type(v) == "boolean" then return v and math.huge or 0 end
    if type(v) == "number" then return v end
    if type(v) == "table" then return tonumber(tryGet(v, "Amount","Count","Qty","Quantity")) or 0 end
    return 0
end

local playerDataCache = LocalData:Get() or {}

for shopKey, shopDef in pairs(ShopsModule) do
    local permanent = shopDef.PermanentItems or {}
    local randomItems = shopDef.RandomItems or {}
    local combined = {}
    for i,entry in pairs(permanent) do combined[i] = entry end
    for i,entry in pairs(randomItems) do combined[i] = entry end

    for slotIndex, slotDef in pairs(combined) do
        local prod = extractProduct(slotDef)
        if matchesExactRule(prod) then
            local costTbl = extractCost(slotDef) or extractCost(slotDef and slotDef.Product) or extractCost(shopDef)
            local pricePer = (costTbl and tonumber(costTbl.Amount)) or nil
            local currencyName = (costTbl and costTbl.Currency) or "(unknown)"
            local stock = tonumber(tryGet(slotDef, "Stock", "MaxStock", "Amount")) or math.huge

            playerDataCache = LocalData:Get() or playerDataCache
            local balance = findCurrencyAmount(playerDataCache, currencyName) or 0

            if not pricePer or pricePer <= 0 then
                local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                local ok, err = safeFire(args)
                if ok then
                    print(("%s Bought ALL x %s Qty:%s Cost:free/unknown"):format(tostring(shopKey), tostring(prod.Name), tostring(stock)))
                end
                task.wait(0.25)
            else
                local maxAffordable = math.floor(balance / pricePer)
                local toBuy = math.min(stock, maxAffordable)
                if toBuy <= 0 then
                    -- cannot afford
                else
                    if toBuy >= stock then
                        local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                        local ok, err = safeFire(args)
                        if ok then
                            local totalCost = pricePer * stock
                            print(("%s Bought ALL (%d) x %s Cost: %s %s"):format(tostring(shopKey), tonumber(stock), tostring(prod.Name), fmtNumber(totalCost), tostring(currencyName)))
                        end
                        task.wait(0.35)
                    else
                        local bought = 0
                        local totalCost = 0
                        for i = 1, toBuy do
                            local args = { "BuyShopItem", tostring(shopKey), slotIndex, false }
                            local ok, err = safeFire(args)
                            if not ok then break end
                            bought = bought + 1
                            totalCost = totalCost + pricePer
                            task.wait(0.22)
                        end
                        if bought > 0 then
                            print(("%s Bought %d x %s Cost: %s %s"):format(tostring(shopKey), bought, tostring(prod.Name), fmtNumber(totalCost), tostring(currencyName)))
                        end
                    end
                end
            end
        end
        task.wait(0.12)
    end
    task.wait(0.25)
end

print("Done.")
