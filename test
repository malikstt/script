for _,x in pairs(getconnections(game.Players.LocalPlayer.Idled)) do x:Disable() end
pcall(function() if game.Players.LocalPlayer.PlayerGui:FindFirstChild("SnowflakesUI") then game.Players.LocalPlayer.PlayerGui.SnowflakesUI:Destroy() end end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

local function getRoot()
    local c = lp.Character or lp.CharacterAdded:Wait()
    return c:WaitForChild("HumanoidRootPart")
end

local Points = {
    CFrame.new(-2605.55,20.60,1115.76),
    CFrame.new(-2710.46,32.90,1190.03),
    CFrame.new(-2598.21,21.22,1069.86),
    CFrame.new(-2447.21,31.83,972.24),
    CFrame.new(-2519.26,20.82,1066.89),
    CFrame.new(-2414.90,31.83,1000.79),
    CFrame.new(-2674.88,32.52,1214.75),
    CFrame.new(-2710.10,32.12,1163.05),
    CFrame.new(-2422.10,31.83,974.31)
}

local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local function getSnow()
    local ok,d = pcall(function() return LocalData:Get() end)
    if ok and d and d.Snowflakes then return d.Snowflakes end
    return 0
end

local function fmt(n)
    n = math.floor(n or 0)
    return tostring(n):reverse():gsub("(%d%d%d)","%1,"):reverse():gsub("^,","")
end

local gui = Instance.new("ScreenGui")
gui.Name = "SnowflakesUI"
gui.Parent = lp:WaitForChild("PlayerGui")
gui.DisplayOrder = 999999
gui.ResetOnSpawn = false

local card = Instance.new("Frame", gui)
card.Size = UDim2.new(0,360,0,140)
card.Position = UDim2.new(1,-380,0,24)
card.BackgroundColor3 = Color3.fromRGB(20,22,30)
card.BorderSizePixel = 0
Instance.new("UICorner", card).CornerRadius = UDim.new(0,14)

local grad = Instance.new("UIGradient", card)
grad.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0,Color3.fromRGB(120,180,255)),
    ColorSequenceKeypoint.new(1,Color3.fromRGB(200,140,255))
}
grad.Rotation = 45
grad.Transparency = NumberSequence.new(0.88,0.9)

local title = Instance.new("TextLabel", card)
title.Size = UDim2.new(1,-20,0,28)
title.Position = UDim2.new(0,10,0,8)
title.BackgroundTransparency = 1
title.Text = "❄️ SNOWFLAKES ❄️"
title.TextColor3 = Color3.new(1,1,1)
title.Font = Enum.Font.GothamBlack
title.TextSize = 20
title.TextXAlignment = Enum.TextXAlignment.Left

local big = Instance.new("TextLabel", card)
big.Size = UDim2.new(1,-20,0,60)
big.Position = UDim2.new(0,10,0,40)
big.BackgroundTransparency = 1
big.Font = Enum.Font.GothamBlack
big.TextSize = 36
big.TextColor3 = Color3.new(1,1,1)
big.TextXAlignment = Enum.TextXAlignment.Left
big.Text = "0"

local rate = Instance.new("TextLabel", card)
rate.Size = UDim2.new(1,-20,0,26)
rate.Position = UDim2.new(0,10,1,-34)
rate.BackgroundTransparency = 1
rate.Font = Enum.Font.GothamBold
rate.TextSize = 16
rate.TextColor3 = Color3.fromRGB(200,200,255)
rate.TextXAlignment = Enum.TextXAlignment.Left
rate.Text = "❄️/min: 0"

local samples = {}
local shown = 0

local function animateNumber(vTo)
    local s = shown
    local t0 = tick()
    local conn
    conn = RunService.Heartbeat:Connect(function()
        local a = math.clamp((tick()-t0)/0.4,0,1)
        shown = s + (vTo - s) * a
        big.Text = fmt(shown)
        if a >= 1 then
            conn:Disconnect()
        end
    end)
end

local function push(v)
    table.insert(samples,{t=tick(),v=v})
    while #samples>1 and tick()-samples[1].t>60 do table.remove(samples,1) end
end

local function perMin()
    if #samples<2 then return 0 end
    local a=samples[1]
    local b=samples[#samples]
    if b.t-a.t<=0 or b.v-a.v<0 then return 0 end
    return ((b.v-a.v)/(b.t-a.t))*60
end

task.spawn(function()
    while true do
        local s = getSnow()
        push(s)
        animateNumber(s)
        rate.Text = "❄️/min: "..fmt(perMin())
        task.wait(1)
    end
end)

local function ensureCharacter()
    local root = getRoot()
    local char = root.Parent
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then repeat task.wait() until char:FindFirstChildOfClass("Humanoid") end
    return root,char,char:FindFirstChildOfClass("Humanoid")
end

local function sweepTouch(cf)
    local root,char,hum = ensureCharacter()
    local base = cf.Position
    local xs = {-2,0,2}
    local zs = {-2,0,2}
    local ys_under = {-6,-4,-2}
    local ys_over = {1,3,5}

    local timeSpent = 0
    local function step(t)
        task.wait(t)
        timeSpent = timeSpent + t
        return timeSpent >= 2
    end

    for _,y in ipairs(ys_under) do
        for _,x in ipairs(xs) do
            for _,z in ipairs(zs) do
                root.CFrame = CFrame.new(base.X+x, base.Y+y, base.Z+z)
                root.AssemblyLinearVelocity = Vector3.new(0,40,0)
                if hum then pcall(function() hum:MoveTo(base+Vector3.new(x,y+1,z)) end) end
                if step(0.15) then return end
            end
        end
    end

    for _,y in ipairs(ys_over) do
        for _,x in ipairs(xs) do
            for _,z in ipairs(zs) do
                root.CFrame = CFrame.new(base.X+x, base.Y+y, base.Z+z)
                root.AssemblyLinearVelocity = Vector3.new(0,-60,0)
                if hum then pcall(function() hum:MoveTo(base+Vector3.new(x,y-1,z)) end) end
                if step(0.15) then return end
            end
        end
    end

    for i=1,2 do
        root.CFrame = CFrame.new(base.X, base.Y+2, base.Z)
        root.AssemblyLinearVelocity = Vector3.new(0,-120,0)
        if step(0.10) then return end

        root.CFrame = CFrame.new(base.X, base.Y-2, base.Z)
        root.AssemblyLinearVelocity = Vector3.new(0,120,0)
        if step(0.10) then return end
    end

    for _,off in ipairs({
        Vector3.new(0,0,0), Vector3.new(1,0,0), Vector3.new(-1,0,0),
        Vector3.new(0,0,1), Vector3.new(0,0,-1)
    }) do
        if hum then
            pcall(function() hum:MoveTo(base+off) end)
            pcall(function() hum:ChangeState(Enum.HumanoidStateType.Running) end)
        end
        if step(0.15) then return end
    end
end

task.spawn(function()
    task.wait(1)
    while true do
        local order = Points
        for _,cf in ipairs(order) do
            sweepTouch(cf)
        end
    end
end)
