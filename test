local ReplicatedStorage = game:GetService("ReplicatedStorage")
local task = task

local ok, LocalData = pcall(function() return require(ReplicatedStorage.Client.Framework.Services.LocalData) end)
if not ok or type(LocalData) ~= "table" then
    LocalData = nil
end

local ok2, ShopsModule = pcall(function() return require(ReplicatedStorage.Shared.Data.Shops) end)
if not ok2 or type(ShopsModule) ~= "table" then
    ShopsModule = nil
end

local function waitForRemote()
    local ok3, shared = pcall(function() return ReplicatedStorage:WaitForChild("Shared", 5) end)
    if not ok3 or not shared then return nil end
    local framework = shared:FindFirstChild("Framework")
    if not framework then return nil end
    local network = framework:FindFirstChild("Network")
    if not network then return nil end
    local remote = network:FindFirstChild("Remote")
    if not remote then return nil end
    local evt = remote:FindFirstChild("RemoteEvent") or remote:FindFirstChildWhichIsA("RemoteEvent")
    return evt
end

local RemoteEvent = waitForRemote()

if LocalData and LocalData.IsReady and type(LocalData.IsReady) == "function" then
    if not LocalData:IsReady() and LocalData.DataReady and LocalData.DataReady.Wait then
        pcall(function() LocalData.DataReady:Wait() end)
    end
end

local function tryGet(t, ...)
    if type(t) ~= "table" then return nil end
    for i = 1, select("#", ...) do
        local k = select(i, ...)
        if t[k] ~= nil then return t[k] end
    end
    return nil
end

local function extractCost(def)
    if type(def) ~= "table" then return nil end
    local c = tryGet(def, "Cost", "Price", "CostInfo", "PriceInfo") or tryGet(def and def.Product, "Cost", "Price")
    if type(c) == "number" then
        local cur = tryGet(def, "Currency", "CurrencyType") or "Currency"
        return { Amount = c, Currency = cur }
    end
    if type(c) == "table" then
        local amt = tryGet(c, "Amount", "Value", "Price", "Cost")
        local cur = tryGet(c, "Currency", "CurrencyType") or tryGet(def, "Currency", "CurrencyType") or "Currency"
        if amt ~= nil then return { Amount = (type(amt)=="number" and amt) or tonumber(amt) or 0, Currency = cur } end
    end
    local amt2 = tryGet(def, "Amount", "Value", "Price", "Cost") or tryGet(def and def.Product, "Amount", "Value")
    local cur2 = tryGet(def, "Currency", "CurrencyType") or tryGet(def and def.Product, "Currency", "CurrencyType")
    if amt2 ~= nil then return { Amount = (type(amt2)=="number" and amt2) or tonumber(amt2) or 0, Currency = cur2 or "Currency" } end
    return nil
end

local function extractProduct(def)
    local p = tryGet(def, "Product", "Reward", "Item", "Result") or def
    if type(p) == "table" then
        return {
            Name = tostring(tryGet(p, "Name", "Label", "Title", "DisplayName", "ItemName") or "(no Name)"),
            Type = tostring(tryGet(p, "Type", "Category") or typeof(p)),
            Level = tonumber(tryGet(p, "Level")) or nil,
            Amount = tonumber(tryGet(p, "Amount", "Quantity", "Count")) or nil
        }
    end
    if typeof(p) == "Instance" then
        return { Name = tostring(p.Name), Type = "Instance", Level = nil, Amount = nil }
    end
    return { Name = tostring(p), Type = typeof(p), Level = nil, Amount = nil }
end

local function fmtNumber(n)
    if type(n) ~= "number" then return tostring(n) end
    local absn = math.abs(n)
    if absn >= 1e15 then return string.format("%.2fP", n/1e15) end
    if absn >= 1e12 then return string.format("%.2fT", n/1e12) end
    if absn >= 1e9  then return string.format("%.2fB", n/1e9) end
    if absn >= 1e6  then return string.format("%.2fM", n/1e6) end
    if absn >= 1e3  then return string.format("%.2fK", n/1e3) end
    return tostring(n)
end

local function findCurrencyAmount(playerData, currencyName)
    if type(playerData) ~= "table" or not currencyName then return 0 end
    if type(playerData[currencyName]) == "number" then return playerData[currencyName] end
    local alt = playerData.Data or playerData.data
    if type(alt) == "table" and type(alt[currencyName]) == "number" then return alt[currencyName] end
    for k,v in pairs(playerData) do
        if type(k) == "string" and string.lower(k) == string.lower(currencyName) and type(v) == "number" then
            return v
        end
        if type(v) == "table" and type(v[currencyName]) == "number" then
            return v[currencyName]
        end
    end
    return 0
end

local function safeFire(argsTable)
    if not RemoteEvent then return false, "no remote" end
    local ok, err = pcall(function() RemoteEvent:FireServer(unpack(argsTable)) end)
    return ok, err
end

local rules = {
    ["Speed"] = 7,
    ["Mythic"] = 7,
    ["Lucky"] = 7,
    ["Luck"] = 7,
    ["Festive Elixir"] = 4,
    ["Festive Infinity Elixir"] = 1,
}

local function matchesRuleExact(prod)
    if type(prod) ~= "table" then return false end
    local name = prod.Name or ""
    local level = prod.Level
    local req = rules[name]
    if req ~= nil then
        if type(req) == "number" then
            return level ~= nil and level == req
        end
        return true
    end
    return false
end

local function qtyFromValue(v)
    if type(v) == "boolean" then return v and math.huge or 0 end
    if type(v) == "number" then return v end
    if type(v) == "table" then return tonumber(tryGet(v, "Amount","Count","Qty","Quantity")) or 0 end
    return 0
end

if not ShopsModule then
    print("No ShopsModule available")
    return
end

if not LocalData then
    print("No LocalData module available; proceeding but player balances may be unknown")
end

local playerDataCache = (LocalData and LocalData.Get and LocalData:Get()) or {}

for shopKey, shopDef in pairs(ShopsModule) do
    local perm = shopDef and shopDef.PermanentItems or {}
    local rand = shopDef and shopDef.RandomItems or {}
    local combined = {}
    for i,entry in pairs(perm) do combined[i] = entry end
    for i,entry in pairs(rand) do combined[i] = entry end

    for slotIndex, slotDef in pairs(combined) do
        local prod = extractProduct(slotDef)
        local okMatch = matchesRuleExact(prod)
        if okMatch then
            local costTbl = extractCost(slotDef) or extractCost(slotDef and slotDef.Product) or extractCost(shopDef)
            local pricePer = (costTbl and tonumber(costTbl.Amount)) or nil
            local currencyName = (costTbl and costTbl.Currency) or "(unknown)"
            local stock = tonumber(tryGet(slotDef, "Stock", "MaxStock", "Amount")) or math.huge

            playerDataCache = (LocalData and LocalData.Get and LocalData:Get()) or playerDataCache
            local balance = findCurrencyAmount(playerDataCache, currencyName) or 0

            if not pricePer or pricePer <= 0 then
                local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                local okfire = safeFire(args)
                if okfire then
                    print(("%s Bought ALL x %s Qty:%s Cost:free/unknown"):format(tostring(shopKey), tostring(prod.Name), tostring(stock)))
                end
                task.wait(0.25)
            else
                local maxAffordable = math.floor(balance / pricePer)
                local toBuy = math.min(stock, maxAffordable)
                if toBuy <= 0 then
                    -- cannot afford
                else
                    if toBuy >= stock then
                        local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                        local okfire = safeFire(args)
                        if okfire then
                            local totalCost = pricePer * stock
                            print(("%s Bought ALL (%d) x %s Cost: %s %s"):format(tostring(shopKey), tonumber(stock), tostring(prod.Name), fmtNumber(totalCost), tostring(currencyName)))
                        end
                        task.wait(0.35)
                    else
                        local bought = 0
                        local totalCost = 0
                        for i = 1, toBuy do
                            local args = { "BuyShopItem", tostring(shopKey), slotIndex, false }
                            local okfire = safeFire(args)
                            if not okfire then break end
                            bought = bought + 1
                            totalCost = totalCost + pricePer
                            task.wait(0.22)
                        end
                        if bought > 0 then
                            print(("%s Bought %d x %s Cost: %s %s"):format(tostring(shopKey), bought, tostring(prod.Name), fmtNumber(totalCost), tostring(currencyName)))
                        end
                    end
                end
            end
        end
        task.wait(0.12)
    end
    task.wait(0.25)
end

print("Done.")
