local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local ShopsModule = require(ReplicatedStorage.Shared.Data.Shops)
if not LocalData:IsReady() then LocalData.DataReady:Wait() end

local function nicePrice(costTbl)
    if type(costTbl) ~= "table" then return tostring(costTbl) end
    local cur = costTbl.Currency or costTbl.CurrencyType or "Currency"
    local amt = costTbl.Amount or costTbl.Value or costTbl.Price or "?"
    return tostring(amt) .. " " .. tostring(cur)
end

local function productNameFromDef(product)
    if type(product) ~= "table" then return tostring(product) end
    if product.Name and product.Name ~= "" then return tostring(product.Name) end
    if product.Label and product.Label ~= "" then return tostring(product.Label) end
    if product.Type then
        local s = tostring(product.Type)
        if product.Name then s = s .. " " .. tostring(product.Name) end
        if product.Level then s = s .. " L" .. tostring(product.Level) end
        return s
    end
    return tostring(product)
end

local function snapshotAllBought(sh)
    local out = {}
    for shopKey, shopVal in pairs(sh or {}) do
        local bought = (shopVal and shopVal.Bought) or {}
        local snap = {}
        for k,v in pairs(bought) do snap[tostring(k)] = v end
        out[tostring(shopKey)] = snap
    end
    return out
end

local function getShopDef(key)
    return ShopsModule[key]
end

local pd = LocalData:Get() or {}
local shopsData = pd.Shops or {}
local prev = snapshotAllBought(shopsData)

task.spawn(function()
    while true do
        pd = LocalData:Get() or {}
        shopsData = pd.Shops or {}
        for shopKey, shopVal in pairs(shopsData) do
            local currentBought = (shopVal and shopVal.Bought) or {}
            local prevBought = prev[tostring(shopKey)] or {}
            for k, v in pairs(currentBought) do
                local ks = tostring(k)
                if prevBought[ks] == nil or tostring(prevBought[ks]) ~= tostring(v) then
                    local qtyText
                    if type(v) == "boolean" then qtyText = v and "ALL" or tostring(v)
                    elseif type(v) == "number" then qtyText = tostring(v)
                    elseif type(v) == "table" then qtyText = tostring(v.Amount or v.Count or v.Qty or v.Quantity or "TABLE")
                    else qtyText = tostring(v) end

                    local slotIndex = tonumber(ks) or ks
                    local shopDef = getShopDef(tostring(shopKey)) or {}
                    local productDef = nil
                    if shopDef.PermanentItems and shopDef.PermanentItems[slotIndex] then productDef = shopDef.PermanentItems[slotIndex]
                    elseif shopDef.RandomItems and shopDef.RandomItems[slotIndex] then productDef = shopDef.RandomItems[slotIndex] end

                    local pname = "UNKNOWN"
                    local price = "UNKNOWN"
                    if productDef then
                        if productDef.Product then
                            pname = productNameFromDef(productDef.Product)
                        else
                            pname = productNameFromDef(productDef)
                        end
                        price = nicePrice(productDef.Cost)
                    end

                    print(string.format("Slot: %s  Qty: %s  Name: %s  Price: %s", tostring(slotIndex), tostring(qtyText), tostring(pname), tostring(price)))
                end
            end
            local newSnap = {}
            for kk,vv in pairs(currentBought) do newSnap[tostring(kk)] = vv end
            prev[tostring(shopKey)] = newSnap
        end
        task.wait(0.5)
    end
end)
