local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local ShopsModule = require(ReplicatedStorage.Shared.Data.Shops)
if not LocalData:IsReady() then LocalData.DataReady:Wait() end

local function fmtNumber(n)
    if type(n) ~= "number" then return tostring(n) end
    local absn = math.abs(n)
    if absn >= 1e15 then return string.format("%.2fP", n/1e15) end
    if absn >= 1e12 then return string.format("%.2fT", n/1e12) end
    if absn >= 1e9  then return string.format("%.2fB", n/1e9) end
    if absn >= 1e6  then return string.format("%.2fM", n/1e6) end
    if absn >= 1e3  then return string.format("%.2fK", n/1e3) end
    return tostring(n)
end

local function tryGet(t, ...)
    if type(t) ~= "table" then return nil end
    for i = 1, select("#", ...) do
        local k = select(i, ...)
        if t[k] ~= nil then return t[k] end
    end
    return nil
end

local function extractCost(def)
    if not def then return nil end
    -- possible locations for cost
    local cost = tryGet(def, "Cost", "Price", "CostInfo", "PriceInfo")
    if type(cost) == "number" then
        local cur = tryGet(def, "Currency", "CurrencyType") or "Currency"
        return { Amount = cost, Currency = cur }
    end
    if type(cost) == "table" then
        local amt = tryGet(cost, "Amount", "Value", "Price", "Cost")
        local cur = tryGet(cost, "Currency", "CurrencyType", "Cur") or tryGet(def, "Currency", "CurrencyType") or "Currency"
        if amt ~= nil then return { Amount = (type(amt)=="number" and amt) or tonumber(amt) or 0, Currency = cur } end
    end
    -- fallback: maybe def has Amount & Currency top-level
    local amt2 = tryGet(def, "Amount", "Value", "Price", "Cost")
    local cur2 = tryGet(def, "Currency", "CurrencyType")
    if amt2 ~= nil then return { Amount = (type(amt2)=="number" and amt2) or tonumber(amt2) or 0, Currency = cur2 or "Currency" } end
    return nil
end

local function extractProduct(def)
    if not def then return nil end
    local p = tryGet(def, "Product", "Reward", "Item", "Result") or def
    -- if it's an Instance
    if typeof(p) == "Instance" then
        local name = p.Name or (p:FindFirstChild("Name") and p.Name) or tostring(p)
        return { Name = name, Type = p.ClassName or "Instance" }
    end
    if type(p) == "table" then
        local name = tryGet(p, "Name", "Label", "Title", "DisplayName", "ItemName")
        if name then return { Name = tostring(name), Type = tostring(tryGet(p, "Type", "Category") or "Unknown") } end
        -- try nested fields commonly used for pets/potions
        if p.Type or p.Level or p.Amount then
            return { Name = tostring(tryGet(p, "Name") or tryGet(p, "Label") or tryGet(p, "Item") or "Unknown"), Type = tostring(tryGet(p, "Type") or "Unknown"), Level = p.Level, Amount = p.Amount }
        end
        -- if it's an indexed table with an id/key
        for k,v in pairs(p) do
            if tonumber(k) then
                local subName = tryGet(v, "Name", "Label")
                if subName then return { Name = tostring(subName), Type = tostring(tryGet(v, "Type") or "Unknown") } end
            end
        end
        -- last resort: tostring the table
        return { Name = tostring(p), Type = "table" }
    end
    return { Name = tostring(p), Type = typeof(p) }
end

local function nicePrice(costTbl)
    if not costTbl then return "UNKNOWN" end
    local amt = costTbl.Amount or costTbl.Value or 0
    return fmtNumber(tonumber(amt) or 0) .. " " .. (costTbl.Currency or costTbl.CurrencyType or "Currency")
end

local function snapshotAllBought(sh)
    local out = {}
    for shopKey, shopVal in pairs(sh or {}) do
        local bought = (shopVal and shopVal.Bought) or {}
        local snap = {}
        for k,v in pairs(bought) do snap[tostring(k)] = v end
        out[tostring(shopKey)] = snap
    end
    return out
end

local function qtyFromValue(v)
    if type(v) == "boolean" then return v and math.huge or 0 end
    if type(v) == "number" then return v end
    if type(v) == "table" then return tonumber(tryGet(v, "Amount","Count","Qty","Quantity")) or 0 end
    return 0
end

local pd = LocalData:Get() or {}
local prev = snapshotAllBought(pd.Shops or {})

task.spawn(function()
    while true do
        pd = LocalData:Get() or {}
        local shopsData = pd.Shops or {}
        for shopKey, shopVal in pairs(shopsData) do
            local currentBought = (shopVal and shopVal.Bought) or {}
            local prevBought = prev[tostring(shopKey)] or {}
            for k, v in pairs(currentBought) do
                local ks = tostring(k)
                local prevV = prevBought[ks]
                local curQty = qtyFromValue(v)
                local prevQty = qtyFromValue(prevV)
                local delta
                if prevV == nil then delta = curQty else
                    if curQty == math.huge or prevQty == math.huge then
                        if curQty == prevQty then delta = 0 else delta = math.huge end
                    else delta = curQty - prevQty end
                end
                if delta ~= 0 and delta ~= nil and (delta > 0 or delta == math.huge) then
                    local slotIndex = tonumber(ks) or ks
                    local shopDef = ShopsModule[tostring(shopKey)] or {}
                    local productDef = nil
                    if shopDef.PermanentItems and shopDef.PermanentItems[slotIndex] then productDef = shopDef.PermanentItems[slotIndex]
                    elseif shopDef.RandomItems and shopDef.RandomItems[slotIndex] then productDef = shopDef.RandomItems[slotIndex] end
                    local prod = extractProduct(productDef)
                    local cost = extractCost(productDef) or extractCost(shopDef) or extractCost(productDef and productDef.Product) or {}
                    local qtyPretty = (delta == math.huge) and "ALL" or tostring(delta)
                    print(string.format("Slot: %s  Qty: %s  Name: %s  Price: %s", tostring(slotIndex), qtyPretty, tostring(prod.Name or "UNKNOWN"), nicePrice(cost)))
                end
            end
            local newSnap = {}
            for kk,vv in pairs(currentBought) do newSnap[tostring(kk)] = vv end
            prev[tostring(shopKey)] = newSnap
        end
        task.wait(0.35)
    end
end)
