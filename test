local ReplicatedStorage = game:GetService("ReplicatedStorage")
local task = task

local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local ShopsModule = require(ReplicatedStorage.Shared.Data.Shops)
local RemoteEvent = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent")

if not LocalData:IsReady() then LocalData.DataReady:Wait() end

local function fmtNumber(n)
    if type(n) ~= "number" then return tostring(n) end
    local absn = math.abs(n)
    if absn >= 1e15 then return string.format("%.2fP", n/1e15) end
    if absn >= 1e12 then return string.format("%.2fT", n/1e12) end
    if absn >= 1e9  then return string.format("%.2fB", n/1e9) end
    if absn >= 1e6  then return string.format("%.2fM", n/1e6) end
    if absn >= 1e3  then return string.format("%.2fK", n/1e3) end
    return tostring(n)
end

local function tryGet(t, ...)
    if type(t) ~= "table" then return nil end
    for i = 1, select("#", ...) do
        local k = select(i, ...)
        if t[k] ~= nil then return t[k] end
    end
    return nil
end

local function extractCost(def)
    if not def then return nil end
    local cost = tryGet(def, "Cost", "Price", "CostInfo", "PriceInfo")
    if type(cost) == "number" then
        local cur = tryGet(def, "Currency", "CurrencyType") or "Currency"
        return { Amount = cost, Currency = cur }
    end
    if type(cost) == "table" then
        local amt = tryGet(cost, "Amount", "Value", "Price", "Cost")
        local cur = tryGet(cost, "Currency", "CurrencyType", "Cur") or tryGet(def, "Currency", "CurrencyType") or "Currency"
        if amt ~= nil then
            return { Amount = (type(amt)=="number" and amt) or tonumber(amt) or 0, Currency = cur }
        end
    end
    local amt2 = tryGet(def, "Amount", "Value", "Price", "Cost")
    local cur2 = tryGet(def, "Currency", "CurrencyType")
    if amt2 ~= nil then return { Amount = (type(amt2)=="number" and amt2) or tonumber(amt2) or 0, Currency = cur2 or "Currency" } end
    return nil
end

local function extractProduct(def)
    if not def then return nil end
    local p = tryGet(def, "Product", "Reward", "Item", "Result") or def
    if type(p) == "table" then
        return p
    end
    return { Name = tostring(p), Type = typeof(p) }
end

local function findCurrencyAmount(playerData, currencyName)
    if not playerData or type(playerData) ~= "table" or not currencyName then return 0 end
    local lowerName = string.lower(tostring(currencyName))

    local function checkTable(t)
        if type(t) ~= "table" then return nil end
        for k,v in pairs(t) do
            if type(k) == "string" and string.lower(k) == lowerName and type(v) == "number" then
                return v
            end
        end
        return nil
    end

    local direct = checkTable(playerData)
    if direct then return direct end

    for _, key in ipairs({"Currencies","Currency","Wallet","Resources","Stats","Balances"}) do
        local ctbl = playerData[key] or playerData[string.lower(key)]
        local found = checkTable(ctbl)
        if found then return found end
    end

    for _,v in pairs(playerData) do
        if type(v) == "table" then
            local found = checkTable(v)
            if found then return found end
        end
    end

    return 0
end

local function safeFire(argsTable)
    local ok, err = pcall(function() RemoteEvent:FireServer(unpack(argsTable)) end)
    return ok, err
end

-- rules: potion name (lowercase) -> required level (number) OR special rule table
local rules = {
    ["speed"] = 7,
    ["mythic"] = 7,
    ["luck"] = 7,
    ["festive elixir"] = 4,
    ["infinity elixir"] = 1, -- "Festive Infinity Elixir" match handled below by contains
}

local function matchesRule(productTbl)
    if type(productTbl) ~= "table" then return false end
    local name = tostring(tryGet(productTbl, "Name", "Label", "Title", "DisplayName", "ItemName") or "")
    local lname = string.lower(name)
    local level = tonumber(tryGet(productTbl, "Level"))
    -- direct name match
    for ruleName, req in pairs(rules) do
        if lname == ruleName or lname:find(ruleName, 1, true) then
            if type(req) == "number" then
                if level and level == req then return true, name, level end
            else
                return true, name, level
            end
        end
    end
    -- special: "Festive Infinity Elixir" might include both "infinity" and "festive"
    if lname:find("infinity",1,true) or lname:find("infinite",1,true) then
        local req = rules["infinity elixir"] or rules["infinity"]
        if req and level and level == req then return true, name, level end
        if req and not level and req == 1 then return true, name, level end
    end
    return false
end

local function qtyFromValue(v)
    if type(v) == "boolean" then return v and math.huge or 0 end
    if type(v) == "number" then return v end
    if type(v) == "table" then return tonumber(tryGet(v, "Amount", "Count", "Qty", "Quantity")) or 0 end
    return 0
end

local playerDataCache = LocalData:Get() or {}

for shopKey, shopDef in pairs(ShopsModule) do
    local permanent = shopDef.PermanentItems or {}
    local randomItems = shopDef.RandomItems or {}
    local allSlots = {}

    for i,entry in pairs(permanent) do allSlots[i] = entry end
    for i,entry in pairs(randomItems) do allSlots[i] = entry end

    for slotIndex, slotDef in pairs(allSlots) do
        local prodTbl = extractProduct(slotDef)
        local ok, pname, plevel = matchesRule(prodTbl)
        if ok then
            local costTbl = extractCost(slotDef) or extractCost(slotDef and slotDef.Product) or extractCost(shopDef)
            local pricePer = (costTbl and tonumber(costTbl.Amount)) or 0
            local currencyName = (costTbl and costTbl.Currency) or "Currency"
            local stock = tonumber(tryGet(slotDef, "Stock", "MaxStock", "Amount")) or math.huge

            playerDataCache = LocalData:Get() or playerDataCache
            local balance = findCurrencyAmount(playerDataCache, currencyName) or 0

            if pricePer <= 0 then
                -- attempt buy-all
                local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                local okfire = safeFire(args)
                if okfire then
                    print(string.format("%s Bought ALL x %s Qty: %s Cost: free/unknown", tostring(shopKey), tostring(pname), tostring(stock)))
                end
                task.wait(0.25)
            else
                local maxAffordable = math.floor(balance / pricePer)
                local toBuy = math.min(stock, maxAffordable)
                if toBuy <= 0 then
                    -- can't afford any
                else
                    if toBuy >= stock then
                        local args = { "BuyShopItem", tostring(shopKey), slotIndex, true }
                        local okfire = safeFire(args)
                        if okfire then
                            local totalCost = pricePer * stock
                            print(string.format("%s Bought ALL (%d) x %s Cost: %s %s", tostring(shopKey), tonumber(stock), tostring(pname), fmtNumber(totalCost), tostring(currencyName)))
                        end
                        task.wait(0.35)
                    else
                        local bought = 0
                        local totalCost = 0
                        for i = 1, toBuy do
                            local args = { "BuyShopItem", tostring(shopKey), slotIndex, false }
                            local okfire = safeFire(args)
                            if not okfire then break end
                            bought = bought + 1
                            totalCost = totalCost + pricePer
                            task.wait(0.25)
                        end
                        if bought > 0 then
                            print(string.format("%s Bought %d x %s Cost: %s %s", tostring(shopKey), bought, tostring(pname), fmtNumber(totalCost), tostring(currencyName)))
                        end
                    end
                end
            end
        end
        task.wait(0.1)
    end
    task.wait(0.25)
end

print("Done.")
