--// =========================================================
--// CIRCUS AUTOMATION â€” FULL WORKING SCRIPT (PURE LUA)
--// =========================================================

--// =========================
--// CONFIG (ONLY THIS)
--// =========================
local UPGRADE_PLAN = {
    { Key = "Currency",     TargetLevel = 4 },
    { Key = "Luck",         TargetLevel = 4 },
    { Key = "SecretLuck",   TargetLevel = 4 },
    { Key = "InfinityLuck", TargetLevel = 4 },
}

--// =========================
--// CONSTANTS (LOCKED)
--// =========================
local WORST_REQUIRED = 10
local MAX_TEAM_SIZE  = 10
local HATCH_DURATION = 30
local BOX_OPEN_DELAY = 2.5
local PICKUP_DELAY   = 0.1

local HATCH_CFRAME   = CFrame.new(-2433.08, 10.14, 264.05)
local CIRCUS_SPAWN   = "Workspace.Circus Event.Spawn"
local EGG_NAME       = "Magic Egg"
local BOX_NAME_MATCH = "Circus Mystery Box"

--// =========================
--// SERVICES / MODULES
--// =========================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local RemoteEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent
local Remote = require(ReplicatedStorage.Shared.Framework.Network.Remote)
local PickupRemote = ReplicatedStorage.Remotes.Pickups.CollectPickup

local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local PetsModule = require(ReplicatedStorage.Shared.Data.Pets)
local CircusUpgrades = require(ReplicatedStorage.Shared.Data.CircusUpgrades)
local PhysicalItem = require(ReplicatedStorage.Client.Effects.PhysicalItem)

--// =========================
--// TELEPORT
--// =========================
RemoteEvent:FireServer("Teleport", CIRCUS_SPAWN)

--// =========================
--// UI
--// =========================
local gui = Instance.new("ScreenGui")
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.Parent = player.PlayerGui

local bg = Instance.new("Frame", gui)
bg.Size = UDim2.fromScale(1,1)
bg.BackgroundColor3 = Color3.fromRGB(10,10,15)
bg.BackgroundTransparency = 0.35

local title = Instance.new("TextLabel", bg)
title.Size = UDim2.fromScale(1,0.08)
title.BackgroundTransparency = 1
title.Text = "ðŸŽª Circus Automation"
title.TextScaled = true
title.Font = Enum.Font.GothamBold
title.TextColor3 = Color3.fromRGB(255,180,255)

local status = Instance.new("TextLabel", bg)
status.Position = UDim2.fromScale(0,0.08)
status.Size = UDim2.fromScale(1,0.05)
status.BackgroundTransparency = 1
status.TextScaled = true
status.Font = Enum.Font.Gotham
status.TextColor3 = Color3.fromRGB(220,220,220)

local panel = Instance.new("Frame", bg)
panel.Position = UDim2.fromScale(0.25,0.22)
panel.Size = UDim2.fromScale(0.5,0.42)
panel.BackgroundColor3 = Color3.fromRGB(20,20,30)
panel.BackgroundTransparency = 0.25
Instance.new("UICorner", panel).CornerRadius = UDim.new(0,18)

local line1 = Instance.new("TextLabel", panel)
line1.Size = UDim2.fromScale(1,0.18)
line1.BackgroundTransparency = 1
line1.TextScaled = true
line1.Font = Enum.Font.GothamBold
line1.TextColor3 = Color3.fromRGB(255,255,255)

local line2 = Instance.new("TextLabel", panel)
line2.Position = UDim2.fromScale(0,0.18)
line2.Size = UDim2.fromScale(1,0.12)
line2.BackgroundTransparency = 1
line2.TextScaled = true
line2.Font = Enum.Font.Gotham
line2.TextColor3 = Color3.fromRGB(200,200,200)

local barBg = Instance.new("Frame", panel)
barBg.Position = UDim2.fromScale(0.1,0.38)
barBg.Size = UDim2.fromScale(0.8,0.08)
barBg.BackgroundColor3 = Color3.fromRGB(50,50,60)
barBg.BackgroundTransparency = 0.2
Instance.new("UICorner", barBg).CornerRadius = UDim.new(1,0)

local bar = Instance.new("Frame", barBg)
bar.Size = UDim2.fromScale(0,1)
bar.BackgroundColor3 = Color3.fromRGB(255,120,255)
Instance.new("UICorner", bar).CornerRadius = UDim.new(1,0)

local info = Instance.new("TextLabel", panel)
info.Position = UDim2.fromScale(0,0.52)
info.Size = UDim2.fromScale(1,0.14)
info.BackgroundTransparency = 1
info.TextScaled = true
info.Font = Enum.Font.Gotham
info.TextColor3 = Color3.fromRGB(180,255,180)

local footer = Instance.new("TextLabel", panel)
footer.Position = UDim2.fromScale(0,0.7)
footer.Size = UDim2.fromScale(1,0.12)
footer.BackgroundTransparency = 1
footer.TextScaled = true
footer.Font = Enum.Font.Gotham
footer.TextColor3 = Color3.fromRGB(200,200,200)

local function setBar(p)
    TweenService:Create(bar, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = UDim2.fromScale(math.clamp(p,0,1),1)
    }):Play()
end

--// =========================
--// HELPERS
--// =========================
local function getData() return LocalData:Get() end
local function getTickets()
    local d = getData()
    return d and d.CircusTickets or 0
end
local function getUpgradeLevel(key)
    local d = getData()
    return d and d.CircusUpgrades and d.CircusUpgrades[key] or 0
end

local function getEquippedIds()
    local d = getData()
    local set = {}
    if d and d.TeamEquipped and d.Teams and d.Teams[d.TeamEquipped] then
        for _,id in ipairs(d.Teams[d.TeamEquipped].Pets or {}) do set[id]=true end
    end
    return set
end

local function circusMulti(pet)
    local info = PetsModule[pet.Name]
    return info and info.Stats and info.Stats.CircusTickets or 0
end

local function analyzeTeam()
    local d = getData()
    local total, worst, worstName = 0, math.huge, "--"
    if d and d.Pets then
        for id,_ in pairs(getEquippedIds()) do
            local pet = d.Pets[id]
            if pet then
                local m = circusMulti(pet)
                total += m
                if m < worst then worst, worstName = m, pet.Name end
            end
        end
    end
    if worst == math.huge then worst = 0 end
    return total, worst, worstName
end

local function equipBestPets()
    local d = getData()
    if not d or not d.Pets then return end
    local pets = {}
    for _,pet in pairs(d.Pets) do
        local m = circusMulti(pet)
        if m > 0 then table.insert(pets, {Id=pet.Id, M=m}) end
    end
    table.sort(pets, function(a,b) return a.M > b.M end)
    local equipped = getEquippedIds()
    for id in pairs(equipped) do
        RemoteEvent:FireServer("UnequipPet", id)
        task.wait(0.1)
    end
    local c = 0
    for i=1,math.min(MAX_TEAM_SIZE,#pets) do
        RemoteEvent:FireServer("EquipPet", pets[i].Id)
        c += 1
        task.wait(0.1)
    end
end

--// =========================
--// PICKUP FARM (ALWAYS)
--// =========================
task.spawn(function()
    local claimed = {}
    while true do
        local r = workspace:FindFirstChild("Rendered")
        if r then
            for _,f in ipairs(r:GetChildren()) do
                for _,o in ipairs(f:GetChildren()) do
                    if not claimed[o.Name] then
                        claimed[o.Name]=true
                        pcall(function()
                            PickupRemote:FireServer(o.Name)
                            o:Destroy()
                        end)
                    end
                end
            end
        end
        task.wait(PICKUP_DELAY)
    end
end)

--// =========================
--// HATCH (HOOK GIFT -> CLAIM)
--// =========================
local oldGift = PhysicalItem.Gift
PhysicalItem.Gift = function(giftId, giftType, pos)
    task.spawn(function()
        pcall(function()
            Remote:FireServer("ClaimGift", giftId)
        end)
    end)
    return nil
end

--// =========================
--// BOX OPENER
--// =========================
local function openCircusBoxes()
    local d = getData()
    if not d or not d.Powerups then return end
    for name,amount in pairs(d.Powerups) do
        if string.find(name, BOX_NAME_MATCH) and amount > 0 then
            while amount > 0 do
                status.Text = "ðŸ“¦ Opening Circus Mystery Boxes"
                line1.Text = name
                line2.Text = "Boxes Remaining"
                Remote:FireServer("UseGift", name, math.min(25, amount))
                task.wait(BOX_OPEN_DELAY)
                amount = (getData().Powerups[name] or 0)
            end
        end
    end
end

--// =========================
--// UPGRADE BUYER
--// =========================
local function buyUpgrades()
    for _,plan in ipairs(UPGRADE_PLAN) do
        local cfg = CircusUpgrades[plan.Key]
        while getUpgradeLevel(plan.Key) < plan.TargetLevel do
            local lvl = getUpgradeLevel(plan.Key)
            local nextU = cfg.Upgrades[lvl+1]
            line1.Text = cfg.Name
            line2.Text = "Level "..lvl.." â†’ "..(lvl+1)
            while getTickets() < nextU.Cost do
                info.Text = "ðŸ’° "..getTickets().." / "..nextU.Cost
                setBar(getTickets()/nextU.Cost)
                task.wait(0.25)
            end
            status.Text = "ðŸ›’ Buying "..cfg.Name
            RemoteEvent:FireServer("BuyCircusUpgrade", plan.Key)
            task.wait(1)
        end
    end
end

--// =========================
--// MAIN LOOP
--// =========================
while true do
    status.Text = "ðŸ” Evaluating Pet Team"
    equipBestPets()
    task.wait(1)

    local total, worst, worstName = analyzeTeam()
    footer.Text = "Worst Pet: "..worstName.." x"..worst
    info.Text = "Total Circus Multiplier: x"..total

    if worst < WORST_REQUIRED then
        status.Text = "ðŸ£ Hatching for Pets [ "..EGG_NAME.." ]"
        player.Character:PivotTo(HATCH_CFRAME)
        local t0 = os.clock()
        while os.clock()-t0 < HATCH_DURATION do
            line1.Text = "Hatching..."
            line2.Text = "Searching better multipliers"
            setBar((os.clock()-t0)/HATCH_DURATION)
            task.wait(0.2)
        end
    else
        openCircusBoxes()
        buyUpgrades()
        status.Text = "âœ… All tasks complete"
        task.wait(5)
    end
end
