local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local BoardModulePath = ReplicatedStorage.Client.Gui.Frames.Board
local BoardUtil = require(ReplicatedStorage.Shared.Utils.BoardUtil)
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local ItemUtil = require(ReplicatedStorage.Shared.Utils.Stats.ItemUtil)
local Remote = require(ReplicatedStorage.Shared.Framework.Network.Remote)
local Board = require(BoardModulePath)

local args = {
    "WorldTeleport",
    "Minigame Paradise"
}
ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent:FireServer(unpack(args))

if FOCUS_DICE and Board and Board.Pieces then
    task.spawn(function()
        while true do
            task.wait(1)

            local playerPiece = Board.Pieces[LocalPlayer.Name]
            local currentData = LocalData:Get()
            if not playerPiece or not currentData then continue end

            local startIndex, totalNodes = playerPiece.Index, #BoardUtil.Nodes
            local stepsNeeded = nil

            for i = 1, totalNodes do
                local currentIndex = ((startIndex + i - 1) % totalNodes) + 1
                local nodeData = BoardUtil.Nodes[currentIndex]
                if nodeData.Type == "infinity" or nodeData.Type == "infinity_elixir" then
                    stepsNeeded = i
                    break
                end
            end

            if not stepsNeeded then
                task.wait(10)
                continue
            end

            local function hasDice(diceName)
                return ItemUtil:GetOwnedAmount(currentData, {Type = "Powerup", Name = diceName}) > 0
            end

            local bestDice = nil

            if USE_GOLDEN_DICE and stepsNeeded <= GOLDEN_DICE_DISTANCE and hasDice("Golden Dice") then
                bestDice = "Golden Dice"
            elseif stepsNeeded <= DICE_DISTANCE and hasDice("Dice") then
                bestDice = "Dice"
            elseif stepsNeeded <= GIANT_DICE_DISTANCE and hasDice("Giant Dice") then
                bestDice = "Giant Dice"
            end

            if not bestDice then
                task.wait(5)
                continue
            end

            local result = Remote:InvokeServer("RollDice", bestDice)
            if result and result.Roll and result.Tile and result.Tile.Index then
                playerPiece.Index = result.Tile.Index
                Remote:FireServer("ClaimTile")
            else
                Remote:FireServer("ClaimTile")
            end

            task.wait(1.5)
        end
    end)
end

if ALWAYS_DICE_CHEST then
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local lastSummonTime = 0
    local COOLDOWN_DURATION = 30 * 60

    local teleportArgs = {
        "WorldTeleport",
        "Minigame Paradise"
    }

    local summonArgs = {
        "SummonRift",
        {
            Name = "dice-rift",
            Type = "Chest",
            Time = 5,
            World = "Minigame Paradise"
        }
    }

    local function teleportToWorld()
        ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent"):FireServer(unpack(teleportArgs))
    end

    local function executeSummon()
        if os.time() - lastSummonTime < COOLDOWN_DURATION then
            return false
        end
        local success = pcall(function()
            ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteFunction"):InvokeServer(unpack(summonArgs))
        end)
        if success then
            lastSummonTime = os.time()
            return true
        end
        return false
    end

    local function getChest()
        return workspace:FindFirstChild("Rendered")
        and workspace.Rendered:FindFirstChild("Rifts")
        and workspace.Rendered.Rifts:FindFirstChild("dice-rift")
        and workspace.Rendered.Rifts["dice-rift"]:FindFirstChild("Chest")
        and workspace.Rendered.Rifts["dice-rift"].Chest:FindFirstChild("dice-rift")
    end

    local function teleportToChest()
        local character = LocalPlayer.Character
        if not character then
            character = LocalPlayer.CharacterAdded:Wait()
        end
        local hrp = character:WaitForChild("HumanoidRootPart")
        local chest = getChest()
        if chest then  
            hrp.CFrame = chest.CFrame * CFrame.new(0, 5, 0)
            return true  
        end  
        return false
    end

    local function spamRE()
        while true do
            if getChest() then
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            else
                break
            end
            wait(0.1)
        end
    end

    teleportToWorld()
    wait(3)

    task.spawn(function()
        while true do
            if not getChest() then
                local summoned = executeSummon()
                if summoned then
                    wait(3)
                end
            end
            if getChest() then  
                if teleportToChest() then
                    spamRE()
                end
            end
            wait(5)
        end
    end)
end
