repeat task.wait() until game:IsLoaded()
local lp=game.Players.LocalPlayer
repeat task.wait() until lp:FindFirstChild("PlayerGui")
task.wait(math.random(0,3000)/1000)
local g=lp.PlayerGui:FindFirstChild("ScreenGui")
if g and g:FindFirstChild("DailyRewards") then g.DailyRewards:Destroy() end
task.spawn(function()
    task.spawn(function()
        local args = {
            "UnlockWorld",
            "Christmas World"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent"):FireServer(unpack(args))

        task.wait(10)

        local args2 = {
            "WorldTeleport",
            "Christmas World"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent"):FireServer(unpack(args2))
    end)

    local Players = game:GetService("Players")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local lp = Players.LocalPlayer

    local function getRoot()
        local char = lp.Character or lp.CharacterAdded:Wait()
        return char:WaitForChild("HumanoidRootPart")
    end

    local Points = {
        CFrame.new(-2605.55, 20.60, 1115.76),
        CFrame.new(-2710.46, 32.90, 1190.03),
        CFrame.new(-2598.21, 21.22, 1069.86),
        CFrame.new(-2447.21, 31.83, 972.24),
        CFrame.new(-2519.26, 20.82, 1066.89),
        CFrame.new(-2414.90, 31.83, 1000.79),
        CFrame.new(-2674.88, 32.52, 1214.75),
        CFrame.new(-2710.10, 32.12, 1163.05),
        CFrame.new(-2422.10, 31.83, 974.31)
    }

    local FarmCFrame = CFrame.new(-2605.67, 20.90, 1089.65)

    local function shuffled(list)
        local t = {}
        for i, v in ipairs(list) do
            t[i] = v
        end
        for i = #t, 2, -1 do
            local j = math.random(i)
            t[i], t[j] = t[j], t[i]
        end
        return t
    end

    local function sweepPad(cf)
        local root = getRoot()
        local basePos = cf.Position
        local yOffsets = {-5, 0, 5}
        local xzOffsets = {-3, 0, 3}

        for _, y in ipairs(yOffsets) do
            for _, x in ipairs(xzOffsets) do
                for _, z in ipairs(xzOffsets) do
                    root.CFrame = CFrame.new(basePos.X + x, basePos.Y + y, basePos.Z + z)
                    pcall(function()
                        root.AssemblyLinearVelocity = Vector3.new(0, -30, 0)
                    end)
                    task.wait(0.25)
                end
            end
        end
    end

    local function teleportTo(cf)
        local root = getRoot()
        root.CFrame = cf
    end

    local function spamE(seconds)
        local start = tick()
        while tick() - start < seconds do
            VirtualInputManager:SendKeyEvent(true, "E", false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, "E", false, game)
            task.wait(0.05)
        end
    end

    task.spawn(function()
        while true do
            local order = shuffled(Points)
            for _, cf in ipairs(order) do
                sweepPad(cf)
            end
            teleportTo(FarmCFrame)
            spamE(60)
        end
    end)

    ALWAYS_TICKET_TEAM = true

    task.spawn(function()
        if ALWAYS_TICKET_TEAM then
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")

            local player = Players.LocalPlayer
            local remote = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent
            local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
            local PetsModule = require(ReplicatedStorage.Shared.Data.Pets)

            local MAX_TEAM_SIZE = 8

            local function getPetInfo(pet)
                local info = PetsModule[pet.Name]
                if not info or not info.Stats then return nil end
                return info
            end

            local function getSortedPets()
                local data = LocalData:Get()
                if not data or not data.Pets then return {} end
                local pets = {}
                for _, pet in pairs(data.Pets) do
                    local info = getPetInfo(pet)
                    if info and info.Stats and info.Stats.Snowflakes then
                        table.insert(pets, {
                            Id = pet.Id,
                            Name = pet.Name,
                            Snowflakes = info.Stats.Snowflakes,
                            Stats = info.Stats
                        })
                    end
                end
                table.sort(pets, function(a, b)
                    return a.Snowflakes > b.Snowflakes
                end)
                return pets
            end

            local function getEquippedTeam()
                local data = LocalData:Get()
                if not data then return {} end
                local equipped = {}
                if data.Teams and data.TeamEquipped then
                    local team = data.Teams[data.TeamEquipped]
                    if team and team.Pets then
                        for _, id in ipairs(team.Pets) do
                            equipped[id] = true
                        end
                    end
                end
                return equipped
            end

            task.spawn(function()
                while task.wait(1) do
                    local data = LocalData:Get()
                    if not data or not data.Pets then continue end

                    local sorted = getSortedPets()
                    if #sorted == 0 then continue end

                    local equipped = getEquippedTeam()

                    local desired = {}
                    for i = 1, math.min(MAX_TEAM_SIZE, #sorted) do
                        desired[sorted[i].Id] = sorted[i]
                    end

                    for id in pairs(equipped) do
                        if not desired[id] then
                            remote:FireServer("UnequipPet", id)
                            task.wait(0.15)
                        end
                    end

                    local currentlyEquipped = 0
                    for id in pairs(equipped) do
                        currentlyEquipped += 1
                    end

                    for id, pet in pairs(desired) do
                        if not equipped[id] and currentlyEquipped < MAX_TEAM_SIZE then
                            remote:FireServer("EquipPet", id)
                            task.wait(0.15)
                            currentlyEquipped += 1
                        end
                    end
                end
            end)
        end
    end)
end)
