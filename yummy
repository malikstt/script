-- SenderAutoTrade.lua

local Config = require(script:WaitForChild("SenderTradeConfig"))

local SenderAutoTrade = {}

SenderAutoTrade.State = {
	active = false,
	currentTarget = nil,
	attempts = {},
}

local function log(...)
	print("[SenderAutoTrade]", ...)
end

function SenderAutoTrade:canTarget(username)
	log("Checking target:", username)

	if Config.targets.blacklist[username] then
		log("Blocked by blacklist:", username)
		return false
	end

	if Config.targets.mode == "all" then
		log("Target allowed (mode=all):", username)
		return true
	end

	if Config.targets.mode == "whitelist" then
		for _, name in ipairs(Config.targets.whitelist) do
			if name == username then
				log("Target allowed (whitelist):", username)
				return true
			end
		end
		log("Target denied (not whitelisted):", username)
		return false
	end

	if Config.targets.mode == "friends" then
		log("Target allowed (friends mode):", username)
		return true
	end

	log("Target denied (unknown mode):", username)
	return false
end

function SenderAutoTrade:selectPets(pets)
	log("Selecting pets from inventory...")
	local selected = {}

	for petId, petData in pairs(pets) do
		if not Config.offer.rules.allowLocked and petData.Locked then
			log("Skipped locked pet:", petId)
			continue
		end

		if not Config.offer.rules.allowEquipped and petData.Equipped then
			log("Skipped equipped pet:", petId)
			continue
		end

		if #Config.offer.filters.includeNames > 0 then
			local ok = false
			for _, n in ipairs(Config.offer.filters.includeNames) do
				if petData.Name == n then
					ok = true
					break
				end
			end
			if not ok then
				log("Skipped by includeNames:", petData.Name)
				continue
			end
		end

		for _, n in ipairs(Config.offer.filters.excludeNames) do
			if petData.Name == n then
				log("Skipped by excludeNames:", petData.Name)
				goto skip
			end
		end

		if #Config.offer.filters.includeTiers > 0 then
			local ok = false
			for _, t in ipairs(Config.offer.filters.includeTiers) do
				if petData.Tier == t then
					ok = true
					break
				end
			end
			if not ok then
				log("Skipped by tier:", petData.Tier)
				continue
			end
		end

		for _, t in ipairs(Config.offer.filters.excludeTiers) do
			if petData.Tier == t then
				log("Skipped by excludeTier:", petData.Tier)
				goto skip
			end
		end

		if petData.Multiplier1 < Config.offer.filters.minMultiplier1 then
			log("Skipped by Multiplier1:", petData.Multiplier1)
			continue
		end

		if petData.Multiplier2 < Config.offer.filters.minMultiplier2 then
			log("Skipped by Multiplier2:", petData.Multiplier2)
			continue
		end

		log("Selected pet:", petId, petData.Name, petData.Tier)
		table.insert(selected, { id = petId, data = petData })

		::skip::
	end

	table.sort(selected, function(a, b)
		if Config.offer.pickStrategy == "highest_multiplier1_first" then
			return a.data.Multiplier1 > b.data.Multiplier1
		end
		return a.data.Multiplier1 < b.data.Multiplier1
	end)

	local result = {}
	for i = 1, math.min(Config.offer.maxPets, #selected) do
		table.insert(result, selected[i].id)
	end

	log("Final pet selection:", table.concat(result, ", "))
	return result
end

function SenderAutoTrade:start()
	if not Config.enabled then
		log("AutoTrade disabled by config")
		return
	end
	self.State.active = true
	log("AutoTrade started")
end

function SenderAutoTrade:stop()
	self.State.active = false
	self.State.currentTarget = nil
	log("AutoTrade stopped")
end

function SenderAutoTrade:onTradeSuccess()
	log("Trade completed successfully")
	if Config.targets.stopAfterSuccess then
		self:stop()
	end
end

function SenderAutoTrade:resetTarget(username)
	self.State.attempts[username] = 0
	log("Reset attempts for:", username)
end

function SenderAutoTrade:recordAttempt(username)
	self.State.attempts[username] = (self.State.attempts[username] or 0) + 1
	log("Attempt", self.State.attempts[username], "for", username)

	if self.State.attempts[username] >= Config.request.maxAttemptsPerTarget then
		log("Max attempts reached for:", username)
		return false
	end
	return true
end

return SenderAutoTrade
