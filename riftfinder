if REMOVE_EGG_ANIMATION then
    require(game:GetService("ReplicatedStorage").Client.Effects.HatchEgg).Play = function() return end
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Network = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteEvent")
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local PetsModule = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Data"):WaitForChild("Pets"))

local function convertToRiftName(displayName)
    return displayName:gsub(" ", "-"):lower()
end

local function findRiftByName()
    local riftNameToFind = convertToRiftName(RIFT_EGG)
    if workspace:FindFirstChild("Rendered") and workspace.Rendered:FindFirstChild("Rifts") then
        for _, rift in pairs(workspace.Rendered.Rifts:GetChildren()) do
            if rift.Name == riftNameToFind then return rift end
        end
    end
end

local function teleportToRift()
    local rift = findRiftByName()
    if rift then
        local character = game.Players.LocalPlayer.Character
        if character and character.PrimaryPart then
            character:SetPrimaryPartCFrame(CFrame.new(rift:GetPivot().Position + Vector3.new(0, 5, 0)))
            return true
        end
    end
    return false
end

local function shouldKeepPet(rarity)
    for _, keepRarity in ipairs(KEEP_RARITIES) do
        if rarity == keepRarity then return true end
    end
    return false
end

local function deleteUnwantedPets()
    local data = LocalData:Get()
    if data and data.Pets then
        for _, pet in pairs(data.Pets) do
            local petInfo = PetsModule[pet.Name]
            if petInfo and not shouldKeepPet(petInfo.Rarity) then
                Network:FireServer("DeletePet", pet.Id, 1000, false)
                task.wait(0.05)
                Network:FireServer("DeletePet", pet.Id, 100, false)
                task.wait(0.05)
                Network:FireServer("DeletePet", pet.Id, 10, false)
                task.wait(0.05)
            end
        end
    end
end

local function executeSummon()
    if not findRiftByName() then
        local worldName = WORLD_2_SUMMON and "Minigame Paradise" or "The Overworld"
        local args = {"SummonRift", {Type = "Egg", Time = 5, Name = RIFT_EGG, Luck = 5, World = worldName}}
        pcall(function()
            ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("RemoteFunction"):InvokeServer(unpack(args))
        end)
    end
end

task.spawn(function()
    while true do
        teleportToRift()
        task.wait(10)
    end
end)

if AUTO_SUMMON then
    task.spawn(function()
        while true do
            if not findRiftByName() then
                executeSummon()
                task.wait(math.random(1, 60))
            else
                task.wait(60)
            end
        end
    end)
end

if AUTO_HATCH then
    task.spawn(function()
        local VirtualInputManager = game:GetService("VirtualInputManager")
        while true do
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.1)
        end
    end)
end

if AUTO_DELETE then
    task.spawn(function()
        while true do
            deleteUnwantedPets()
            task.wait(20)
        end
    end)
end

getgenv().running = not getgenv().running

local potions = {
    {"Coins", 6},
    {"Speed", 6},
    {"Lucky", 6},
    {"Mythic", 6},
    {"Tickets", 6}
}

if not ALWAYS_EVOLVED_POTIONS then
    table.insert(potions, {"Coins", 5})
    table.insert(potions, {"Tickets", 5})
end

if ALWAYS_EGG_ELIXIR then
    table.insert(potions, {"Egg Elixir", 1})
end

if ALWAYS_INFINITY_ELIXIR then
    table.insert(potions, {"Infinity Elixir", 1})
end

if ALWAYS_SECRET_ELIXIR then
    table.insert(potions, {"Secret Elixir", 1})
end

while getgenv().running do
    for _, potion in ipairs(potions) do
        local args = {"UsePotion", potion[1], potion[2]}
        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer(unpack(args))
        task.wait(0.5)
    end
end
