-- SERVICES
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- PLAYER
local player = Players.LocalPlayer

-- MODULES
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local PetsModule = require(ReplicatedStorage.Shared.Data.Pets)

-- UI
local gui = Instance.new("ScreenGui")
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local bg = Instance.new("Frame")
bg.Size = UDim2.fromScale(1, 1)
bg.BackgroundColor3 = Color3.new(0, 0, 0)
bg.BorderSizePixel = 0
bg.Parent = gui

local FONT = Enum.Font.Code
local COLOR = Color3.fromRGB(235, 235, 235)

local function label(parent, size, pos, align, textSize)
    local l = Instance.new("TextLabel")
    l.BackgroundTransparency = 1
    l.Size = size
    l.Position = pos
    l.Text = ""
    l.Font = FONT
    l.TextColor3 = COLOR
    l.TextWrapped = true
    l.TextXAlignment = align or Enum.TextXAlignment.Left
    l.TextYAlignment = Enum.TextYAlignment.Center
    l.TextSize = textSize
    l.Parent = parent
    return l
end

-- HEADER
local header = label(
    bg,
    UDim2.fromScale(1, 0.07),
    UDim2.fromScale(0, 0),
    Enum.TextXAlignment.Center,
    40
)
header.Text = "-------------- "..player.Name.." --------------"

-- HATCHING BOX
local hatchText = label(
    bg,
    UDim2.fromScale(1, 0.16),
    UDim2.fromScale(0, 0.1),
    Enum.TextXAlignment.Center,
    36
)

-- LEFT
local leftText = label(
    bg,
    UDim2.fromScale(0.45, 0.4),
    UDim2.fromScale(0.05, 0.32),
    Enum.TextXAlignment.Left,
    34
)

-- RIGHT
local rightText = label(
    bg,
    UDim2.fromScale(0.45, 0.4),
    UDim2.fromScale(0.5, 0.32),
    Enum.TextXAlignment.Left,
    34
)

-- HELPERS
local function fmt(n)
    if not n then return "0" end
    if n >= 1e12 then return string.format("%.2fT", n/1e12)
    elseif n >= 1e9 then return string.format("%.2fB", n/1e9)
    elseif n >= 1e6 then return string.format("%.2fM", n/1e6)
    elseif n >= 1e3 then return string.format("%.2fK", n/1e3)
    else return tostring(n) end
end

local function getLuckTime()
    local icon = workspace:FindFirstChild("SummonedEgg")
        and workspace.SummonedEgg:FindFirstChild("Sign")
        and workspace.SummonedEgg.Sign:FindFirstChild("Display")
        and workspace.SummonedEgg.Sign.Display:FindFirstChild("SurfaceGui")
        and workspace.SummonedEgg.Sign.Display.SurfaceGui:FindFirstChild("Icon")

    if not icon then return "x0", "N/A" end
    local luck = icon:FindFirstChild("Luck")
    local timer = icon:FindFirstChild("Timer")
    return luck and luck.Text or "x0", timer and timer.Text or "N/A"
end

local function countSecrets(data)
    local inv, team = 0, 0
    if data and data.Pets then
        for _, pet in pairs(data.Pets) do
            local info = PetsModule[pet.Name]
            if info and info.Rarity == "Secret" then
                inv += 1
            end
        end
    end
    if data and data.Teams and data.TeamEquipped then
        local t = data.Teams[data.TeamEquipped]
        if t and t.Pets then
            for _, id in ipairs(t.Pets) do
                local pet = data.Pets[id]
                if pet then
                    local info = PetsModule[pet.Name]
                    if info and info.Rarity == "Secret" then
                        team += 1
                    end
                end
            end
        end
    end
    return inv, team
end

-- TRACKING
local lastEggs = {}
local currentEgg = "â€”"

local eggHistory = {}
local eggsPerMin = 0

task.spawn(function()
    while true do
        local data = LocalData:Get()
        local now = tick()

        -- current egg detection
        if data and data.EggsOpened then
            for egg, count in pairs(data.EggsOpened) do
                local prev = lastEggs[egg]
                if prev and count > prev then
                    currentEgg = egg
                end
                lastEggs[egg] = count
            end
        end

        -- eggs/min from Stats.Hatches (rolling 60s window)
        local h = data and data.Stats and data.Stats.Hatches
        if h then
            table.insert(eggHistory, {time = now, value = h})

            while #eggHistory > 0 and now - eggHistory[1].time > 60 do
                table.remove(eggHistory, 1)
            end

            if #eggHistory >= 2 then
                eggsPerMin = eggHistory[#eggHistory].value - eggHistory[1].value
            else
                eggsPerMin = 0
            end
        end

        local luck, timeLeft = getLuckTime()
        local invS, teamS = countSecrets(data)

        hatchText.Text =
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"..
            "â”‚ ğŸ¥š Hatching: "..currentEgg.."\n"..
            "â”‚ ğŸŒŸ Total Secrets: "..invS.."\n"..
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        leftText.Text =
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"..
            "â”‚ ğŸ€ Luck: "..luck.."\n"..
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n"..
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"..
            "â”‚ âš¡ Eggs/min: "..fmt(eggsPerMin).."\n"..
            "â”‚ ğŸ¥š Eggs: "..fmt(h or 0).."\n"..
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        rightText.Text =
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"..
            "â”‚ â³ Time: "..timeLeft.."\n"..
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n"..
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"..
            "â”‚ ğŸ’ Gems: "..fmt(data and data.Gems).."\n"..
            "â”‚ ğŸ¾ Secrets: "..teamS.."\n"..
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        task.wait(0.5)
    end
end)
task.spawn(function()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Lighting = game:GetService("Lighting")
    local ws = workspace
    local lp = Players.LocalPlayer
    local char = lp.Character or lp.CharacterAdded:Wait()

    local keep = {}
    local function k(x) if x then keep[x] = true end end

    k(ws.CurrentCamera)

    local rendered = ws:FindFirstChild("Rendered")
    if rendered then
        k(rendered)
        for _,v in ipairs(rendered:GetDescendants()) do k(v) end
    end

    local egg = ws:FindFirstChild("SummonedEgg")
    if egg then
        k(egg)
        for _,v in ipairs(egg:GetDescendants()) do k(v) end
    end

    local eggsFolder = ws:FindFirstChild("Eggs")
    if eggsFolder then
        k(eggsFolder)
        for _,v in ipairs(eggsFolder:GetDescendants()) do k(v) end
    end

    k(char)
    for _,v in ipairs(char:GetDescendants()) do k(v) end

    lp.CharacterAdded:Connect(function(c)
        task.wait(0.4)
        char = c
        k(c)
        for _,v in ipairs(c:GetDescendants()) do k(v) end
    end)

    local surf = Instance.new("Part")
    surf.Size = Vector3.new(2000,20,2000)
    surf.Position = Vector3.new(0,5,0)
    surf.Anchored = true
    surf.CanCollide = true
    surf.Transparency = 1
    surf.Parent = ws

    local function isChar(o)
        return lp.Character and (o == lp.Character or o:IsDescendantOf(lp.Character))
    end

    local function safe(o)
        return not (
            o:IsA("Script")
            or o:IsA("LocalScript")
            or o:IsA("ModuleScript")
            or o:IsA("RemoteEvent")
            or o:IsA("RemoteFunction")
        )
    end

    local function d(i)
        if i and i.Parent and not keep[i] and not isChar(i) and safe(i) then
            pcall(function() i:Destroy() end)
        end
    end

    local function batch(list,b,w)
        local i,n=1,#list
        while i<=n do
            for j=i,math.min(i+b-1,n) do d(list[j]) end
            i+=b
            task.wait(w)
        end
    end

    local function collect(pred)
        local t={}
        for _,o in ipairs(ws:GetDescendants()) do
            if pred(o) then table.insert(t,o) end
        end
        return t
    end

    task.wait(1)

    batch(collect(function(o)
        return o:IsA("MeshPart")
        or o:IsA("SpecialMesh")
        or o:IsA("UnionOperation")
        or o:IsA("Texture")
        or o:IsA("Decal")
        or o:IsA("ParticleEmitter")
        or o:IsA("Beam")
        or o:IsA("Trail")
        or o:IsA("Fire")
        or o:IsA("Smoke")
        or o:IsA("Sparkles")
        or o:IsA("Highlight")
        or o:IsA("SurfaceAppearance")
    end),40,0.35)

    task.wait(0.8)

    batch(collect(function(o)
        return o:IsA("Adornment")
        or o:IsA("SelectionBox")
        or o:IsA("SelectionSphere")
        or o:IsA("ArcHandles")
    end),20,0.3)

    task.wait(0.6)

    batch(collect(function(o)
        return not o:IsA("BasePart")
        and safe(o)
    end),30,0.5)

    task.wait(1)

    local t2={}
    for _,c in ipairs(ws:GetChildren()) do
        if not keep[c] and safe(c) then
            table.insert(t2,c)
        end
    end
    batch(t2,3,0.7)

    task.wait(0.6)

    local t3={}
    for _,v in ipairs(Lighting:GetChildren()) do
        table.insert(t3,v)
    end
    batch(t3,8,0.4)

    task.wait(0.6)

    pcall(function()
        RunService:Set3dRenderingEnabled(false)
    end)

    task.spawn(function()
        while true do
            local r = ws:FindFirstChild("Rendered")
            if r then
                local children = r:GetChildren()
                local target = children[14]
                if target then
                    for _,obj in ipairs(target:GetChildren()) do
                        if obj and obj.Parent and not keep[obj] and safe(obj) then
                            pcall(function() obj:Destroy() end)
                        end
                    end
                end
            end
            task.wait(0.1)
        end
    end)

    if egg then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local base = egg.PrimaryPart or egg:FindFirstChildWhichIsA("BasePart")
        if hrp and base then
            hrp.CFrame = base.CFrame * CFrame.new(0, base.Size.Y/2 + 3, 0)
        end
    end
end)
