if game.PlaceId ~= 95383978784657 then return end
if not request then return end

local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local CS = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")

local Replication = require(RS.Game.Replication)
local Network = require(RS.Modules.Network)

local LP = Players.LocalPlayer

local WEBHOOK_URL = "https://discord.com/api/webhooks/1466018830391312532/fUDtg2f_MNlYnc449bHOqON5CMiQp4d8eHbUpNfOBrXOZlyY2zGyD7iT_EL61bYVz_qX"

getgenv().AutoSellConfig = getgenv().AutoSellConfig or {
	Enabled = true,
	ScanInterval = 1.5,
	MaxListings = 15,
	Pets = {
		-- old pets with updated prices
		["Surge Dragon"] = 50,
		["Dual Shock"] = 100,
		["Overcharged Robot"] = 250,
		-- new pets
		["Fortunate Calico"] = 250,
		["SUPER Luckyblock"] = 60,
		["JACKPOT"] = 675,
		["Frost Queen"] = 10
	}
}

local listed, busy = {}, false
local lastPets, sent = {}, {}
local tracked = {}

local function getAmount(p)
	local amt = getgenv().AutoSellConfig.Pets[p.Name]
	if not amt then return end
	if p.Tier and p.Tier ~= "Normal" then return end
	return amt
end

local function sendSold(petId, info)
	if sent[petId] then return end
	sent[petId] = true

	request({
		Url = WEBHOOK_URL,
		Method = "POST",
		Headers = {["Content-Type"]="application/json"},
		Body = HttpService:JSONEncode({
			username = "Auto Sell",
			embeds = {{
				title = "ðŸ’¸ Pet Sold",
				color = 0xff5555,
				fields = {
					{name="Player", value=LP.Name, inline=true},
					{name="Pet", value=info.name or "Unknown", inline=true},
					{name="Tier", value=info.tier or "Normal", inline=true},
					{name="Amount", value="+ "..tostring(info.amount or 0).." tokens", inline=true},
					{name="Pet ID", value=tostring(petId), inline=true}
				},
				timestamp = DateTime.now():ToIsoDate()
			}}
		})
	})
end

local function snapshot()
	local t = {}
	for id in pairs(Replication.Data.Pets or {}) do
		t[id] = true
	end
	return t
end

-- RANDOM LISTING (no priority)
local function autoList()
	if busy or not getgenv().AutoSellConfig.Enabled then return end
	busy = true

	local pets = Replication.Data.Pets or {}
	local pool = {}

	-- build pool of valid config pets
	for id, p in pairs(pets) do
		if not listed[id]
			and not p.Locked
			and not p.Trading
			and p.Tier == "Normal"
			and getgenv().AutoSellConfig.Pets[p.Name] then
			pool[#pool+1] = { id = id, pet = p }
		end
	end

	-- shuffle pool
	for i = #pool, 2, -1 do
		local j = math.random(i)
		pool[i], pool[j] = pool[j], pool[i]
	end

	local c = 0
	for _, entry in ipairs(pool) do
		if c >= getgenv().AutoSellConfig.MaxListings then break end

		local p = entry.pet
		local id = entry.id
		local amt = getAmount(p)

		if amt then
			local sellAmt = math.ceil(amt)
			if Network:InvokeServer("ListItem", "Pet", id, sellAmt) then
				listed[id] = true
				tracked[id] = {
					name = p.Name,
					tier = p.Tier or "Normal",
					amount = sellAmt
				}
				c += 1
			end
			task.wait(0.15)
		end
	end

	busy = false
end

task.spawn(function()
	while true do
		pcall(autoList)
		task.wait(getgenv().AutoSellConfig.ScanInterval)
	end
end)

task.spawn(function()
	lastPets = snapshot()
	while true do
		task.wait(1)
		local now = snapshot()

		for id in pairs(lastPets) do
			if not now[id] then
				local info = tracked[id]
				if info then
					sendSold(id, info)
					tracked[id] = nil
				end
			end
		end

		lastPets = now
	end
end)

local function countConfigPets()
	local c = 0
	for _, p in pairs(Replication.Data.Pets or {}) do
		if p.Tier == "Normal" and getgenv().AutoSellConfig.Pets[p.Name] then
			c += 1
		end
	end
	return c
end

task.spawn(function()
	while true do
		task.wait(30)
		if countConfigPets() == 0 then
			pcall(function() LP:Kick("Out of configured pets") end)
			return
		end
	end
end)

local function ownBooth()
	for _,b in ipairs(CS:GetTagged("Booth")) do
		if b:GetAttribute("BoothOwner") == LP.UserId then
			return b
		end
	end
end

local function hrp()
	local ch = LP.Character or LP.CharacterAdded:Wait()
	return ch:WaitForChild("HumanoidRootPart")
end

local function randPlr()
	local t = {}
	for _,p in ipairs(Players:GetPlayers()) do
		if p ~= LP and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			t[#t+1] = p
		end
	end
	if #t == 0 then return end
	return t[math.random(#t)]
end

task.spawn(function()
	repeat task.wait(0.2) until #CS:GetTagged("Booth") > 0
	math.randomseed(os.clock())
	local r = 20

	while true do
		local ob = ownBooth()
		if ob and ob.PrimaryPart then
			local h = hrp()
			h.CFrame = ob.PrimaryPart.CFrame * CFrame.new(0,5,0)
			return
		end

		local tp = randPlr()
		if tp and tp.Character and tp.Character:FindFirstChild("HumanoidRootPart") then
			local pos = tp.Character.HumanoidRootPart.Position
			for _,b in ipairs(CS:GetTagged("Booth")) do
				if b.PrimaryPart and b:GetAttribute("BoothOwner") == nil
				and (b.PrimaryPart.Position - pos).Magnitude <= r then
					Network:InvokeServer("ClaimBooth", b)
					local t0 = tick()
					while tick() - t0 < 1 do
						if b:GetAttribute("BoothOwner") == LP.UserId then
							local h = hrp()
							h.CFrame = b.PrimaryPart.CFrame * CFrame.new(0,5,0)
							h.AssemblyLinearVelocity = Vector3.zero
							h.AssemblyAngularVelocity = Vector3.zero
							return
						end
						task.wait()
					end
				end
			end
		end

		r += 20
		task.wait(0.5)
	end
end)
