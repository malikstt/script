local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local vim = game:GetService("VirtualInputManager")

local lp = Players.LocalPlayer
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local Config = getgenv().EggConfig

pcall(function()
    local m = require(ReplicatedStorage.Client.Effects.HatchEgg)
    m.Play = function() return end
end)

local function pressE()
    vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
    task.wait()
    vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

_G.Hatch = function()
    pressE()
end

local function parseNumber(str)
    str = tostring(str):upper()
    local n = tonumber(str:match("[%d%.]+")) or 0
    if str:find("K") then return n * 1e3 end
    if str:find("M") then return n * 1e6 end
    if str:find("B") then return n * 1e9 end
    if str:find("T") then return n * 1e12 end
    return n
end

local function getSnow()
    local d = LocalData:Get()
    return (d and d.Snowflakes) or 0
end

local function convert(name)
    return name:gsub(" ", "-"):lower()
end

local function getLuck(r)
    local d = r:FindFirstChild("Display")
    local g = d and d:FindFirstChildOfClass("SurfaceGui")
    local i = g and g:FindFirstChild("Icon")
    local l = i and i:FindFirstChild("Luck")
    return l and tonumber(l.Text:match("%d+")) or 0
end

local function getCF(m)
    if typeof(m.GetPivot) == "function" then
        local ok, p = pcall(m.GetPivot, m)
        if ok and p then return p end
    end
    if m.PrimaryPart then return m.PrimaryPart.CFrame end
    local part = m:FindFirstChildWhichIsA("BasePart", true)
    return part and part.CFrame or nil
end

local function tp(m)
    local cf = getCF(m)
    if not cf then return false end
    local char = lp.Character or lp.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    hrp.CFrame = cf + Vector3.new(0,5,0)
    return true
end

local lastTP = 0
local function canTP()
    return tick() - lastTP >= Config.teleport_debounce
end

task.spawn(function()
    while true do
        if not Config.enabled then
            task.wait(Config.check_interval)
            continue
        end

        local needed = parseNumber(Config.min_snowflakes_before_hatch)
        if getSnow() < needed then
            task.wait(Config.check_interval)
            continue
        end

        local selected = Config.selected_egg
        local riftName = convert(selected)

        local bestRift = nil
        local bestLuck = -1

        local rifts = Workspace:FindFirstChild("Rendered") and Workspace.Rendered:FindFirstChild("Rifts")
        if rifts then
            for _, r in ipairs(rifts:GetChildren()) do
                if r:GetAttribute("Type") == "Egg" and r.Name == riftName then
                    local l = getLuck(r)
                    if l >= Config.min_selected_egg_rift and l > bestLuck then
                        bestLuck = l
                        bestRift = r
                    end
                end
            end
        end

        if bestRift and canTP() then
            if tp(bestRift) then
                lastTP = tick()
                _G.Hatch()
            end
        else
            local generic = Workspace:FindFirstChild("Rendered") and Workspace.Rendered:FindFirstChild("Generic")
            if generic then
                local egg = generic:FindFirstChild(selected)
                if egg and canTP() then
                    if tp(egg) then
                        lastTP = tick()
                        _G.Hatch()
                    end
                end
            end
        end

        task.wait(Config.check_interval)
    end
end)
