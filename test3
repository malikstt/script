-- main.lua
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local vim = game:GetService("VirtualInputManager")

local lp = Players.LocalPlayer
local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local Config = require(path.to.EggConfig)

-- HATCHER
pcall(function()
	local ok, hatchModule = pcall(function()
		return require(ReplicatedStorage.Client.Effects.HatchEgg)
	end)
	if ok and type(hatchModule) == "table" and hatchModule.Play then
		hatchModule.Play = function() return end
	end
end)

local function pressE()
	vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
	task.wait()
	vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

local function hatchUntilDone()
	while true do
		local gui = Players.LocalPlayer.PlayerGui
		if not gui or not gui:FindFirstChild("Hatch") then
			break
		end
		pressE()
		task.wait()
	end
end

_G.Hatch = function()
	pressE()
	hatchUntilDone()
end

-- UTIL
local function getSnow()
	local d = LocalData:Get()
	return (d and d.Snowflakes) or 0
end

local function convertToRiftName(name)
	return name:gsub(" ", "-"):lower()
end

local function getLuck(rift)
	local d = rift:FindFirstChild("Display")
	local g = d and d:FindFirstChildOfClass("SurfaceGui")
	local i = g and g:FindFirstChild("Icon")
	local l = i and i:FindFirstChild("Luck")
	return l and tonumber(l.Text:match("%d+")) or 0
end

local function getModelCFrame(model)
	if not model then return nil end
	if typeof(model.GetPivot) == "function" then
		local ok, pivot = pcall(model.GetPivot, model)
		if ok and pivot then return pivot end
	end
	if model.PrimaryPart then return model.PrimaryPart.CFrame end
	local p = model:FindFirstChildWhichIsA("BasePart", true)
	if p then return p.CFrame end
	return nil
end

local function tpToCFrame(cf)
	if not cf then return end
	local char = lp.Character or lp.CharacterAdded:Wait()
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if hrp then hrp.CFrame = cf + Vector3.new(0,5,0) end
end

local function tpToModel(model)
	local cf = getModelCFrame(model)
	if cf then
		tpToCFrame(cf)
		return true
	end
	return false
end

local lastTeleport = 0
local function canTeleport()
	return (tick() - lastTeleport) >= Config.runtime.teleport_debounce
end

getgenv().DELETE_RIFT_BELOW = Config.rift.destroy_rift_if_luck_below

-- MAIN LOOP
task.spawn(function()
	while true do
		local snow = getSnow()
		if snow < Config.egg.min_snowflakes_before_hatch then
			task.wait(Config.runtime.check_interval)
		else
			local foundRift = nil
			local bestLuck = -1

			local riftsFolder = Workspace:FindFirstChild("Rendered") and Workspace.Rendered:FindFirstChild("Rifts")
			if riftsFolder then
				for _, rift in ipairs(riftsFolder:GetChildren()) do
					if rift:GetAttribute("Type") == "Egg" then
						local luck = getLuck(rift)

						if luck < Config.rift.destroy_rift_if_luck_below then
							pcall(function() rift:Destroy() end)
						end

						local targetName = (Config.rift.rift_egg_name ~= "" and Config.rift.rift_egg_name) or convertToRiftName(Config.egg.selected)
						if rift.Name == targetName and luck >= Config.rift.min_rift_luck_to_hatch_rift then
							if luck > bestLuck then
								bestLuck = luck
								foundRift = rift
							end
						end
					end
				end
			end

			if foundRift and canTeleport() then
				if tpToModel(foundRift) then
					lastTeleport = tick()
					for i = 1, Config.egg.amount do
						if getSnow() < Config.egg.min_snowflakes_before_hatch then break end
						_G.Hatch()
						task.wait(0.3)
					end
				end
			else
				local genericFolder = Workspace:FindFirstChild("Rendered") and Workspace.Rendered:FindFirstChild("Generic")
				if genericFolder then
					local selected = genericFolder:FindFirstChild(Config.egg.selected)
					if selected and canTeleport() then
						if bestLuck < Config.egg.min_rift_luck_to_use_selected then
							if tpToModel(selected) then
								lastTeleport = tick()
								for i = 1, Config.egg.amount do
									if getSnow() < Config.egg.min_snowflakes_before_hatch then break end
									_G.Hatch()
									task.wait(0.3)
								end
							end
						end
					end
				end
			end

			task.wait(Config.runtime.check_interval)
		end
	end
end)
