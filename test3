getgenv().waitTime = 2.5

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
repeat task.wait() until player.Character
local char = player.Character
local hrp = char:WaitForChild("HumanoidRootPart")

local LocalDataModule = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local RemoteFunction = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteFunction

local activeRift = nil
local lastKeyChange = tick()
local lastKeyAmount = nil

local function getLocalData()
    return LocalDataModule:Get()
end

local function getAmount(name)
    local data = getLocalData()
    return (data and data.Powerups and data.Powerups[name]) or 0
end

local function setNoClip(state)
    for _, v in pairs(char:GetDescendants()) do
        if v:IsA("BasePart") then
            v.CanCollide = not state
        end
    end
end

local function getChestFromRift(rift)
    local chest = rift:FindFirstChild("Chest", true)
    if chest then
        return chest:FindFirstChildWhichIsA("BasePart")
    end
end

local function teleportToChest()
    if not activeRift then return end
    local chest = getChestFromRift(activeRift)
    if not chest then return end
    setNoClip(true)
    hrp.CFrame = chest.CFrame
    task.wait()
    setNoClip(false)
end

local function watchRift(rift)
    if activeRift then return end
    activeRift = rift

    local chest = getChestFromRift(rift)
    if chest then
        teleportToChest()
    end

    rift.DescendantAdded:Connect(function(d)
        if d.Name == "Chest" then
            teleportToChest()
        end
    end)
end

task.spawn(function()
    local rendered = workspace:WaitForChild("Rendered")
    local rifts = rendered:WaitForChild("Rifts")

    for _, rift in pairs(rifts:GetChildren()) do
        if rift.Name == "dice-rift" then
            watchRift(rift)
            break
        end
    end

    rifts.ChildAdded:Connect(function(rift)
        if rift.Name == "dice-rift" then
            watchRift(rift)
        end
    end)
end)

task.spawn(function()
    while true do
        local current = getAmount("Dice Key")
        if lastKeyAmount == nil then
            lastKeyAmount = current
            lastKeyChange = tick()
        elseif current ~= lastKeyAmount then
            lastKeyAmount = current
            lastKeyChange = tick()
        elseif current > 0 and tick() - lastKeyChange >= 30 then
            teleportToChest()
            lastKeyChange = tick()
        end
        task.wait(1)
    end
end)

task.spawn(function()
    while true do
        if activeRift and getAmount("Dice Key") > 0 then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
        end
        task.wait(0.05)
    end
end)

task.spawn(function()
    while true do
        if not activeRift then
            local found = false
            local checks = math.random(0,10)
            for i = 1, checks do
                if workspace:FindFirstChild("Rendered")
                    and workspace.Rendered:FindFirstChild("Rifts") then
                    for _, r in pairs(workspace.Rendered.Rifts:GetChildren()) do
                        if r.Name == "dice-rift" then
                            found = true
                            break
                        end
                    end
                end
                if found then break end
                task.wait(1)
            end
            if not found then
                RemoteFunction:InvokeServer(
                    "SummonRift",
                    {
                        Name = "dice-rift",
                        Type = "Chest",
                        Time = 5,
                        World = "Minigame Paradise"
                    }
                )
            end
        end
        task.wait(5)
    end
end)

local gui = Instance.new("ScreenGui")
gui.Name = "DiceUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.fromOffset(200,200)
frame.Position = UDim2.new(0.5,-100,0,10)
frame.BorderSizePixel = 0
frame.Parent = gui
Instance.new("UICorner", frame).CornerRadius = UDim.new(0,16)

local function makeLabel(y, size, bold)
    local l = Instance.new("TextLabel")
    l.Size = UDim2.new(1,-16,0,size)
    l.Position = UDim2.new(0,8,0,y)
    l.BackgroundTransparency = 1
    l.TextScaled = true
    l.Font = bold and Enum.Font.GothamBold or Enum.Font.Gotham
    l.TextColor3 = Color3.new(1,1,1)
    l.Parent = frame
    return l
end

local nameLabel = makeLabel(6,34,true)
local diceKeyLabel = makeLabel(48,38,true)
local superTicketLabel = makeLabel(90,32,false)
local goldenDiceLabel = makeLabel(128,32,false)

RunService.Heartbeat:Connect(function()
    local diceKeys = getAmount("Dice Key")
    frame.BackgroundColor3 = diceKeys > 0 and Color3.fromRGB(45,120,255) or Color3.fromRGB(200,45,45)
    nameLabel.Text = "ğŸ‘¤ "..player.Name
    diceKeyLabel.Text = "ğŸ² Dice Key : "..diceKeys
    superTicketLabel.Text = "ğŸŸï¸ Super Ticket : "..getAmount("Super Ticket")
    goldenDiceLabel.Text = "âœ¨ Golden Dice : "..getAmount("Golden Dice")
end)
