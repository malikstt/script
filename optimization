--// Services
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")

--// Modules
local Replication = require(RS.Game.Replication)
local Network = require(RS.Modules.Network)

--// Player
local LP = Players.LocalPlayer

--// =========================
--// CONFIG (Auto Sell)
--// =========================
getgenv().AutoSellConfig = {
	Enabled = true,
	ScanInterval = 1.5,
	MaxListings = 15,
	Pets = {
		["Surge Dragon"] = 50,
		["Dual Shock"] = 150,
		["Overcharged Robot"] = 650
	}
}

--// =========================
--// Booth Claimer (from 2nd script)
--// =========================
local function getCharacter()
	local character = LP.Character or LP.CharacterAdded:Wait()
	local hrp = character:WaitForChild("HumanoidRootPart")
	return character, hrp
end

repeat task.wait(0.2) until #CollectionService:GetTagged("Booth") > 0
math.randomseed(os.clock())

local function shuffle(t)
	for i = #t, 2, -1 do
		local j = math.random(i)
		t[i], t[j] = t[j], t[i]
	end
end

local function getRandomPlayer()
	local candidates = {}
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LP and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			table.insert(candidates, plr)
		end
	end
	if #candidates == 0 then return nil end
	return candidates[math.random(#candidates)]
end

local function getBoothsNearPosition(pos, range)
	local results = {}
	for _, booth in ipairs(CollectionService:GetTagged("Booth")) do
		if booth.PrimaryPart and booth:GetAttribute("BoothOwner") == nil then
			local dist = (booth.PrimaryPart.Position - pos).Magnitude
			if dist <= range then
				table.insert(results, booth)
			end
		end
	end
	return results
end

local function alreadyOwnBooth()
	for _, booth in ipairs(CollectionService:GetTagged("Booth")) do
		if booth:GetAttribute("BoothOwner") == LP.UserId then
			return booth
		end
	end
	return nil
end

local function claimBooth()
	print("üß† Player-based booth claimer started")

	-- if already own booth, tp to it and stop
	local owned = alreadyOwnBooth()
	if owned then
		print("‚úÖ Already own booth:", owned.Name)
		local _, hrp = getCharacter()
		hrp.CFrame = owned.PrimaryPart.CFrame * CFrame.new(0, 5, 0)
		return true
	end

	local range = 20

	while true do
		-- if we got one while looping, stop
		local ownedNow = alreadyOwnBooth()
		if ownedNow then
			print("üéâ Booth claimed (detected):", ownedNow.Name)
			local _, hrp = getCharacter()
			hrp.CFrame = ownedNow.PrimaryPart.CFrame * CFrame.new(0, 5, 0)
			hrp.AssemblyLinearVelocity = Vector3.zero
			hrp.AssemblyAngularVelocity = Vector3.zero
			return true
		end

		local targetPlayer = getRandomPlayer()
		if targetPlayer then
			local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
			if targetHRP then
				print("üéØ Using player:", targetPlayer.Name, "range:", range)

				local candidates = getBoothsNearPosition(targetHRP.Position, range)
				if #candidates > 0 then
					shuffle(candidates)

					for _, booth in ipairs(candidates) do
						print("‚û°Ô∏è Trying booth near", targetPlayer.Name, ":", booth.Name)
						Network:InvokeServer("ClaimBooth", booth)

						-- wait for server confirmation
						local start = tick()
						while tick() - start < 1 do
							if booth:GetAttribute("BoothOwner") == LP.UserId then
								print("üéâ Booth claimed:", booth.Name)

								local _, hrp = getCharacter()
								hrp.CFrame = booth.PrimaryPart.CFrame * CFrame.new(0, 5, 0)
								hrp.AssemblyLinearVelocity = Vector3.zero
								hrp.AssemblyAngularVelocity = Vector3.zero

								return true
							end
							task.wait()
						end
					end
				end
			end
		end

		range += 20
		task.wait(0.5)
	end
end

--// =========================
--// Auto Lister (from 1st script)
--// =========================
local listed = {}
local busy = false

local function getPrice(pet)
	local baseName = pet.Nickname or pet.Name
	local basePrice = getgenv().AutoSellConfig.Pets[baseName]
	if not basePrice then return nil end

	local tier = pet.Tier
	if tier == "Normal" then
		return basePrice
	elseif tier == "Golden" then
		return basePrice * 5
	elseif tier == "Rainbow" then
		return basePrice * 10
	end

	return nil
end

local function autoList()
	if busy or not getgenv().AutoSellConfig.Enabled then return end
	busy = true

	local listings = 0
	for petId, pet in pairs(Replication.Data.Pets or {}) do
		if listings >= getgenv().AutoSellConfig.MaxListings then break end

		if not listed[petId] and not pet.Locked and not pet.Trading then
			local price = getPrice(pet)
			if price then
				local success = Network:InvokeServer("ListItem", "Pet", petId, math.ceil(price))
				if success then
					listed[petId] = true
					listings += 1
				end
				task.wait(0.15)
			end
		end
	end

	busy = false
end

--// =========================
--// RUN BOTH
--// =========================

-- 1) Claim a booth first (blocks until success)
pcall(function()
	claimBooth()
end)

-- 2) Then start auto listing loop
task.spawn(function()
	while true do
		pcall(autoList)
		task.wait(getgenv().AutoSellConfig.ScanInterval)
	end
end)
