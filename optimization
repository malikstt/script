local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local API_BASE = "https://chips-workers-hammer-consulting.trycloudflare.com"
local Config = {
    SellerUsername = "Keiyoz",
    CheckInterval = 5,
    OnlyPets = true,
    StrictMatchTokens = true,
}

local LP = Players.LocalPlayer
local lastTriedJobId = nil
local isBuying = false

local Replication = require(ReplicatedStorage:WaitForChild("Game"):WaitForChild("Replication"))
local Network = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"))

local function getTokens()
    return tonumber(Replication.Data and Replication.Data.Items and Replication.Data.Items.PaidTokens) or 0
end

local function safeRequest(opts)
    local ok, res = pcall(function()
        return request(opts)
    end)
    if not ok then return nil end
    return res
end

local function safeJSONDecode(body)
    if type(body) ~= "string" or body == "" then return nil end
    local ok, decoded = pcall(function()
        return HttpService:JSONDecode(body)
    end)
    if not ok then return nil end
    return decoded
end

local function safeInvokeServer(...)
    local ok, result = pcall(function()
        return Network:InvokeServer(...)
    end)
    if not ok then return nil end
    return result
end

local function resolveSellerId()
    local ok, id = pcall(function()
        return Players:GetUserIdFromNameAsync(Config.SellerUsername)
    end)
    if ok and type(id) == "number" then
        return id
    end
    return nil
end

-- heartbeat update (unchanged behavior; just wrapped)
task.spawn(function()
    while true do
        safeRequest({
            Url = API_BASE .. "/update",
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode({
                role = "alt",
                username = LP.Name,
                userId = LP.UserId,
                tokens = getTokens()
            })
        })
        task.wait(5)
    end
end)

local function startBuyingLogic(sellerId)
    if isBuying then return end
    isBuying = true

    -- Ensure we ALWAYS clear isBuying even if something errors.
    local function cleanup()
        isBuying = false
    end

    local ok = xpcall(function()
        while isBuying do
            local tokens = getTokens()
            if tokens <= 0 then
                break
            end

            local listings = safeInvokeServer("GetBoothListings", sellerId)
            if type(listings) == "table" then
                for listingId, data in pairs(listings) do
                    if type(data) == "table" then
                        local price = tonumber(data.itemPrice)
                        local pass = true

                        if Config.OnlyPets and data.itemType ~= "Pet" then
                            pass = false
                        end
                        if Config.StrictMatchTokens and price ~= tokens then
                            pass = false
                        end

                        if pass and price and price <= tokens then
                            local success = safeInvokeServer("BuyItem", sellerId, listingId)
                            if success then
                                -- stop loop; cleanup will run after returning
                                return
                            end
                        end
                    end
                end
            end

            task.wait(Config.CheckInterval)
        end
    end, function()
        -- Swallow errors; avoid crashing the thread.
        -- (No prints to avoid spamming; add warn(...) if you want.)
    end)

    cleanup()
    return ok
end

task.spawn(function()
    local sellerId = resolveSellerId()

    while true do
        -- Retry sellerId occasionally if it was nil
        if not sellerId then
            sellerId = resolveSellerId()
        end

        local res = safeRequest({ Url = API_BASE .. "/main", Method = "GET" })
        if res and res.Body then
            local decoded = safeJSONDecode(res.Body)
            local data = decoded and decoded.data

            if type(data) == "table" then
                local mainJobId = data.jobId
                local placeId = data.placeId
                local currentTokens = getTokens()

                -- basic sanity checks
                if type(mainJobId) ~= "string" or mainJobId == "" then
                    mainJobId = nil
                end
                if type(placeId) ~= "number" then
                    placeId = nil
                end

                if mainJobId and game.JobId == mainJobId then
                    if sellerId then
                        startBuyingLogic(sellerId)
                    end
                elseif currentTokens > 0 and mainJobId and placeId and mainJobId ~= lastTriedJobId then
                    lastTriedJobId = mainJobId
                    pcall(function()
                        TeleportService:TeleportToPlaceInstance(placeId, mainJobId, LP)
                    end)
                end
            end
        end

        task.wait(3)
    end
end)
